---
title: "S4 Classes and Methods"
author: "Martin Morgan"
date: "July 31 - August 1, 2018"
vignette: >
  %\VignetteIndexEntry{S4}
  %\VignetteEngine{knitr::rmarkdown}
output: 
  BiocStyle::html_document
---

```{r style, echo = FALSE, results = 'asis'}
knitr::opts_chunk$set(
    eval=as.logical(Sys.getenv("KNITR_EVAL", "TRUE")),
    cache=as.logical(Sys.getenv("KNITR_CACHE", "TRUE")))
```

# Object systems

## S3

- Class defined by presence of a 'class' attribute
- Generic function defined by presence of `UseMethod()` as body.
- Methods defined _on the generic_.

- Loose class definition
- Linear inheritance
- Single dispatch
- Generally, no distinction between 'user' interface and 'developer'
  implementation

## S4

Formal...

- ... class definition -- `setClass()`
- ... generic definition -- `setGeneric()`
- ... method definition -- `setMethod()`

Benefits

- Programatic access to class definition
  - Complex data representations possible
  - Encourages separation of user 'API' from developer implementation
- Multiple inheritance
- Multiple dispatch


Goal: develop a class to represent gene sets

- A collection of gene symbols

A base _R_ representation might be

```{r}
sets <- list(
    set1 = sample(letters, 7),
    set2 = sample(LETTERS, 5)
)
```

# S3 classes and methods: motivation

Create a vector of 300 random normal deviates. These are of class `numeric`. `summary()` describes the vector.

```{r}
x <- rnorm(300)
class(x)
summary(x)
```

Create a second vector and coordinate with the first in a data.frame, an object of class `data.frame`. `summary()` describes the data.frame.

```{r}
y <- x + rnorm(300)
df <- data.frame(x, y)
class(df)
summary(df)
```

Plot the relationship between x and y

```{r}
plot(x, y)
```

Plot the relationship between x and y using a formula. The formula is actually an object, with class `formula`.

```{r}
plot(y ~ x, df)
class(y ~ x)
```

Fit a linear model relating y and x. The fit is an object of class `lm`. `summary()` displays an ANOVA table.

```{r}
fit <- lm(y ~ x, df)
fit
class(fit)
summary(fit)
```

Add a regression line to the plot.

```{r}
plot(y ~ x, df)
abline(fit, col = "red", lwd = 3)
```

Notice that we have encountered several different _classes_ (numeric vector, data.frame, formula, "lm") and that the same function `summary()`, `plot()`, and `print()` (we use `print()` implicitly, whenever _R_ displays the result of an expression evalauted on the command line) behave differently depending on the class of the first argument to the function. Look at the following

```{r}
summary
plot
print
```

and inspecting the code of `abline()` note that there is a call to `coef()`

```{r}
coef
```

All of these functions share the same body, with a call to `UseMethod()`. This indicates that they are _S3 generic_ functions. 

`UseMethod()` signals to _R_ that it should look for a specific _S3 method_ (a function) to use. S3 defines a method as a function that has a name composed of the name of the generic function, a `.`, and the name of the class of the first argument to the generic function. Thus our use of `summary()` generic actually invoked

- `summary.data.frame()`
- `summary.lm()`
- `summary.default()` (a special method, used when no other method matches).

Methods are sometimes not visible to the user (they are not necessary exported from the NAMESPACE of the package in which they are defined). Discover available methods with `methods()`

```{r}
methods(plot)
```

and use `getAnywhere()` to see the definition of a method, e.g., `getAnywhere("plot.lm")`.

A practical consequence of understanding methods is in navigating the help system.

```{r, eval = FALSE}
?plot
```

provides help on the generic `plot` (high-level functionality common to all plotting methods)

```{r, eval = FALSE}
?plot.lm
```

provides help on the `plot` method for `lm` objects.

# Creating S3 classes and methods

## Act 1: list-of-vectors representation

Remember our gene sets

```{r}
sets
```

We can make this an S3 class simply by adding a class attribute. The output is modified to include the class attribute. Generics like `names()` and `lengths()` continue to work -- _R_ looks for an S3 method `names.gene_set` but does not find one, so uses the default method.

```{r}
s3geneset <- sets
class(s3geneset) <- "gene_set"
sets
names(s3geneset)
lengths(s3geneset)
```

Follow best practices and make a _constructor_ that will take arguments and create an object of class `gene_set`

```{r}
gene_set <- function(...) {
    args <- list(...)            # make a list from separate arguments
    class(args) <- "gene_set"    # provide a class attribute
    args
}
```

Here it is in action

```{r}
gs <- gene_set(set1 = letters[1:7], set2 = LETTERS[1:5])
gs
```

Define a new method on the `print()` generic to provide a different display of the object. Create the method by simply writing a function `print.gene_set()`:

```{r}
print.gene_set <- function(x) {
    cat(
        "S3 class: ", class(x), "\n",
        "names(): ", paste(names(x), collapse=" "), "\n",
        "lengths(): ", paste(lengths(x), collapse=" "), "\n",
        sep=""
    )
}
```

And check out the (implicit) outcome of invoking the `print` generic on our new method

```{r}
gs
```

One problem with our class is that `[`-subsetting returns a `list` rather than `gene_set`. `[` is a generic, so we can write a method for gene set. The signature of the method matches the signature of the generic, even though we will not use the `j` argument. The body of the function has a call to `NextMethod()`, which is S3's syntax for saying 'apply the generic to the next-best match', in this case the next-best match is the default subsetting method, so `result` is a list. 

```{r}
`[.gene_set` <- function(x, i, j, ..., drop = TRUE) {
    result <- NextMethod()      # next-best method, `[.default`, returns a list
    do.call("gene_set", result) # invoke the constructor with `result` as args
}
```

Subsetting now returns a `gene_set`.

```{r}
gs[1]
gs[ c("set2", "set1", "set2") ]
```

Our implementation is not very robust, for instance the following breaks the expectation that genes in a set are represented by `character()` values.

```{r}
gs1 <- gs
gs1$set1 <- 1:5
```

## Act 2: tidy representation

The `tidyverse` is a very helpful way of tackling problems in data analysis. It emphasizes a data.frame-like class called a `tibble`, and the structuring of data into rectangular tables rather than more complicated representations like the lists-of-vectors representation in `sets`.

A tidy representation of gene sets might be

```{r, message=FALSE}
library(tidyverse)
tbl <- tibble(
    gene = unlist(sets, use.names = FALSE),
    set = rep(names(sets), lengths(sets))
)
tbl
```

The class of `tbl` illustrates that the S3 system supports a linear hierarchy of classes

```{r}
class(tbl)
```

Most generally, `tbl` is a `data.frame`. But at least some methods are implemented by specialized methods defined on the `tbl` class, and even more specialized methods on the `tbl_df` class.

```{r}
methods(class="tbl")
methods(class="tbl_df")
```

Here's a constructor to make a tibble-based gene set; we make this class by further specializing the class of tibble

```{r}
gene_set_tbl <- function(...) {
    args <- list(...)
    tbl <- tibble(
        gene = unlist(args, use.names = FALSE),
        set = rep(names(args), lengths(args))
    )
    class(tbl) <- c("gene_set_tbl", class(tbl))  # subclass of 'tbl_df', ...
    tbl
}
```

Implement `names()`, `lengths()` and `print()` methods for our new class

```{r}
names.gene_set_tbl = function(x) {
    unique(x$set)
}
    
lengths.gene_set_tbl = function(x, use.names = TRUE) {
    lengths <- as.vector(table(x$set))
    if (use.names)
        names(lengths) <- names(x)
    lengths
}
    
print.gene_set_tbl = function(x, ...) {
    cat(
        "class: ", class(x)[1], "\n",
        "names(): ", paste(names(x), collapse=", "), "\n",
        "lengths(): ", paste(lengths(x), collapse=", "), "\n",
        sep=""
    )
}
```

and check out the 'API' (interface) to our new class

```{r}
gst <- gene_set_tbl(set1 = letters[1:7], set2 = LETTERS[1:5])
gst
names(gst)
lengths(gst)
```

## Comment

Note that the _interface_ is exactly the same as the `gene_set` class

```{r}
gs <- gene_set(set1 = letters[1:7], set2 = LETTERS[1:5])
gs
names(gs)
lengths(gs)
```

even though the _implementation_ is completly different! This is a very important property -- the developer can choose an implementation that is appropriate for, e.g., computational efficiency, while exposing an interface that is convenient to use.

# S4 class and methods: `data.frame`-like implementation

There are many different ways one could choose to represent a gene set. There can be great value in working with 'tidy'-looking data such as a long data.frame-like object. We start by defining a class to represent gene sets in a data.frame-like manner.

## Class definition

Use `setClass()` to define our class. `slots` are like 'fields' in Java / C++. We'll represent our data in a *column-oriented* fashion, rather than row-oriented -- the object represents two columns, rather than 1 row with fields `gene` and `set`. This means that a single column-oriented object can represent `n` gene sets, rather than requiring `n` row-oriented objects to represent `n` genes.

```{r}
.GeneSetDf <- setClass(
    "GeneSetDf",
    slots = c(
        gene = "character", 
        set = "factor"
    )
)
```

`setClass()` returns a kind of internal constructor that can be used to create instances of our new class. `.GeneSetDf()` is a constructor that is useful for _developers_, but not usually for users. It takes arguments named after slots, e.g.,

```{r}
.GeneSetDf(
    gene = c("A", "B", "C", "D"),
    set = factor(c("set1", "set1", "set1", "set2"))
)
```

S4 classes have formal definitions, and it is possible to discover and programmatically consult the class definition

```{r}
getClass("GeneSetDf")
```

## Accessors

It is always a good idea to write convenience functions that access the data contained in the slots. The accessors may simply access the slot directly (as below), but the abstraction provided by the function provides the developer with a great deal of flexibility in designing and implementing their class. Here are some plain-old-functions to access the `gene` and `set` slots; they start with a dot (`.`) as a convention to indicate that they are meant only for developer use.

```{r}
.GeneSetDf_gene <- function(x)
    slot(x, "gene")

.GeneSetDf_set <- function(x)
    slot(x, "set")
```

Accessors can be plain functions, or a generic with methods. Let's make them generics with methods. There are no existing generics `gene()` or `set()`, so define the generics

```{r}
setGeneric("gene", function(x) standardGeneric("gene"))

setGeneric("set", function(x) standardGeneric("set"))
```

Implement the methods using our existing plain-old-functions

```{r}
setMethod("gene", "GeneSetDf", .GeneSetDf_gene)

setMethod("set", "GeneSetDf", .GeneSetDf_set)
```

Accessors provide a layer to separate what the user interfaces with (`gene()`, `set()`) versus what the developer thinks is an efficient representation.

There are two other useful accessor-like functions. `names()` returns the gene set names, while `lengths()` returns the length of each gene set. Here are our internal definitions

```{r}
.GeneSetDf_names <- function(x)
    levels(set(x))

.GeneSetDf_lengths <-
    function(x, use.names = TRUE)
{
    lengths <- as.vector(table(set(x)))
    if (use.names)
        names(lengths) <- names(x)
    lengths
}
```

The `names()` function is a generic (see `getGeneric("names")`), so the method is easily defined

```{r}
setMethod("names", "GeneSetDf", .GeneSetDf_names)
```

`lengths()` is a plain-old-function. We promote it to a generic and implement a method

```{r}
setGeneric("lengths")

setMethod("lengths", "GeneSetDf", .GeneSetDf_lengths)
```

Discover available methods with `showMethods()`

```{r}
showMethods("gene")

showMethods(classes = "GeneSetDf", where = .GlobalEnv)
```

## Validity

Class definitions ensure each slot contains the correct _type_ of data, but there are often other constraints, e.g., that `gene` and `set` are the same length. Write a function that tests the validity of the object. The contract is: return TRUE if valid, or a character vector describing how the object is not valid.

```{r}
.GeneSetDf_validity <-
    function(object)
{
    msg <- NULL
    
    if (length(gene(object)) != length(set(object)))
        msg <- c(msg, "length of 'gene' must equal length of 'set'")
    
    if (is.null(msg)) TRUE else msg
}
```

Use `setValidity()` to associate the class with the function that tests its validity.

```{r}
setValidity("GeneSetDf", .GeneSetDf_validity)
```

## A constructor for users

`.GeneSetDf()` exposes slots directly to the caller, but usually one wants to separate the 'implementation' details (i.e., slots) from the 'interface' seen by the user. So we write a user-facing constructor that provides convenient ways to create our object.

For instance, it might be convenient if `GeneSetDf()` could be invoked with a list of named character vectors `GeneSetDf(list(set1 = letters[1:3], set2 = LETTERS[1:5}))` or with named arguments defining the gene set `GeneSetDf(set1 = letters[1:3], set2 = LETTERS[1:5])`.

This user-facing convenience does not influence the representation of the object.

```{r}
GeneSetDf <-
    function(...)
{
    args <- list(...)

    if (length(args) == 0L) {
        args <- list(character())
    } else if (length(args) == 1L && is(args, "list"))
        args <- args[[1]]

    .GeneSetDf(
        gene = unlist(unname(args)),
        set = factor(
            rep(names(args), lengths(args)),
            levels = names(args)
        )
    )
}
```

## A `show,GeneSetDf-method`

`show()` is a generic that has as it's contract to print the object. `show()` is an existing generic (see `getGeneric("show")`). Since genomic data are usually large, we try to implement a `show()` method that is not overwhelmed by large data.

```{r}
setMethod(
    "show", "GeneSetDf",
    function(object)
{
    cat("class: ", class(object), "\n",
        "names(): ", paste(names(object), collapse = " "), "\n",
        "lengths(): ", paste(lengths(object), collapse = " "), "\n",
        sep = ""
    )
})
```

Here's our interface in action...

```{r}
gs <- GeneSetDf(sets)
gs
gene(gs)
set(gs)
```

# S4 class and method: `list`-like implementation

There is usually more than one way to represent data. Here's a different implementation based on lists. It's worth thinking about the pros and cons of this implementation. Since the implementation is a detail meaningful to the developer, it is possible to switch implementations _without_ changing the user-facing interface. We do this to some extent here.

## Class definition

The `GeneSet` class is very simple -- it 'contains' (extends) `list`, i.e., the gene sets will be represented as lists of character vectors.

```{r}
.GeneSet <- setClass(
    "GeneSet",
    contains = "list"
)
```

## Accessors

We could write accessors for this class, too, even though there are no `gene` or `set` slots.

```{r}
setMethod("gene", "GeneSet", function(x) unlist(x, use.names = FALSE))

setMethod(
    "set", "GeneSet",
    function(x)
{
    set <- rep(names(x), lengths(x))
    factor(set, levels = names(x))
})
```

Inheritance from the contained 'list' representation gives us `names()` and `lengths()` without any additional code!

## Validity

We need to ensure that all elements of the list are `character()`, that all list elements are named, and that there are no identically named gene sets.

```{r}
.GeneSet_validity <- function(object) {
    msg <- NULL

    types <- vapply(object, is, logical(1), "character")
    if (!all(types))
        msg <- c(msg, "'GeneSet' members must be character()")

    if (sum(nzchar(names(object))) != length(object))
        msg <- c(msg, "Each 'GeneSet' must be named")

    if (any(duplicated(names(object))))
        msg <- c(msg, "'GeneSet' names must be unique")

    if (is.null(msg)) TRUE else msg
}

setValidity("GeneSet", .GeneSet_validity)
```

## A constructor for users

Our user-facing contructor will accept either a list of gene sets, or a series of named arguments, each representing a gene set.

```{r}
GeneSet <-
    function(...)
{
    args <- list(...)

    if (length(args) == 1L && is(args[[1]], "list"))
        args <- args[[1]]

    .GeneSet(args)
}
```

## A `show,GeneSet-method`

The `show,GeneSet-method` presents the data in the same way as the `show,GeneSetDf-method`. The interface, from the user perspective, is the same between the two different classes. The implementation, from the developer perspective, is the same.

```{r}
setMethod(
    "show", "GeneSet",
    function(object)
{
    cat(
        "class: ", class(object), "\n",
        "names(): ", paste(names(object), collapse=" "), "\n",
        "lengths(): ", paste(lengths(object), collapse=" "), "\n",
        sep=""
    )
})
```

Here's our interface so far; the user interacts with this class in exactly the same way as for `GeneSetDf`, even though the classes are implemented in very different ways.

```{r}
GeneSet(sets)
GeneSet(A = letters[1:4], B = LETTERS[1:3])
gs <- GeneSet(sets)
gs
gene(gs)
set(gs)
```

## Subsetting and update: `[`, `[[`, `[<-`, `[[<-`

The list-like definition of `GeneSet` suggest that we would like to be able to implement other aspects of the 'list' interface, especially `[` and `[[` subsetting and updating.

Note that the default `[` does not work quite as we would like -- it returns a list, rather than a `GeneSet`

```{r}
gs[1]   ## list, rather than GeneSet
```

We address this by writing a new method for `[`. Here's the generic

```{r}
getGeneric("[")
```

Note the signature of the generic, and that there are _four_ arguments that can be dispatched on. Here's one definition of the `[,GeneSet-method`.

```{r}
setMethod(
    "[", c("GeneSet", "ANY", "missing", "missing"),
    function(x, i, j, ..., drop = TRUE)
{
    result <- callNextMethod()
    result <- as(result, "GeneSet")
    validObject(result)
    result
})
```

And we can see that `[` now returns a `GeneSet`

```{r}
gs[1]
gs[c("set2", "set1")]
```

The default `[[` method works fine for our purposes, so we do not need to implement a method.

```{r}
gs[[1]]
gs[["set2"]]
```

The next task is to write a _replacement_ method. This method will update the value of the object. Here's the generic, again with four arguments in its signature.

```{r}
getGeneric("[<-")
```

The `setReplaceMethod()` function is used to implement the method:

```{r}
setReplaceMethod(
    "[", signature = c("GeneSet", "ANY", "missing", "ANY"),
    function(x, i, j, ..., value)
{
    if (length(i) != length(value))
        stop("'GeneSet' replacement value length not equal to length(i)")
    if (any(nzchar(names(value))) && !all(names(x)[i] == names(value)))
        stop("'GeneSet' replacement names do not equal GeneSet names")

    result <- callNextMethod()
    validObject(result)

    result
})
```

Here's the replacement method in action, updating the value of the gene set

```{r}
gs1 <- gs2 <- gs
gs1[2] <- list(LETTERS[5:10])
gs1[[2]]
gs2[[2]]
```

We'd also like to be able to update individual sets using `[[<-`.

```{r}
setReplaceMethod(
    "[[", signature = c("GeneSet", "ANY", "missing", "ANY"),
    function(x, i, j, ..., value)
{
    result <- callNextMethod()
    result <- as(result, "GeneSet")
    validObject(result)
    result
})
```

## Coercion

_Coercion_ methods enable commands like `as(gs, "data.frame")`. These special methods are defined using `setAs()`. For example, we write a function that will coerce a `GeneSet` to a `data.frame`.

```{r}
.GeneSet_as_data_frame <-
    function(from)
{
    data.frame(
        gene = unlist(unname(from)),
        set = factor(
            rep(names(from), lengths(from)), 
            levels = names(from)
        ),
        stringsAsFactors = FALSE
    )
}
```

We then implement S4 functionality for `as(gs, "data.frame")`

```{r}
setAs("GeneSet", "data.frame", .GeneSet_as_data_frame)
```

and for convenience implement `as.data.frame(gs)` using the same helper function

```{r}
as.data.frame.GeneSet <- 
    function(x, row.names = NULL, optional = FALSE, ...)
{
    .GeneSet_as_data_frame(x)
}
```

# Exercises

1. Improve the `show()` method for `GeneSet` so that the first
   several genes of the first several sets are displayed
   
    ```{r}
    .select_some <-
        function(x, n = 6)
    {
        if (length(x) > n)
            x <- c(head(x, n - 1), "...")
        paste(x, collapse = " ")
    }
    
    setMethod(
        "show", "GeneSet",
        function(object)
    {
        cat(
            "class: ", class(object), "\n",
            "length(): ", length(object), "\n",
            "names(): ", paste(names(object), collapse=" "), "\n",
            "lengths(): ", paste(lengths(object), collapse=" "), "\n",
            sep=""
        )
        for (i in seq_len(min(length(object), 6)))
            cat(
                '[["', names(object)[i], '"]]: ',
                    .select_some(object[[i]]), "\n",
                sep = ""
            )
        if (length(object) > 6)
            cat("...\n")
    })
    ```

2. Improve the `show()` method for `GeneSetDf` to print the first
   several genes of the first several sets in a data.frame-like format,

    ```
    gene    set
       a   set1
       b   set1
       c   set1
     ...    ...
       A   set2
       B   set2
       C   set2
     ...    ...
     ...    ...
    ```

3. Write `setAs()` methods to coerce a `GeneSetDf` to and from a `data.frame`

    ```{r}
    .GeneSetDf_as_data_frame <-
        function(from)
    {
        data.frame(
            gene = gene(from), set = set(from), 
            stringsAsFactors = FALSE
        )
    }
    
    as.data.frame.GeneSetDf <- 
        function(x, row.names = NULL, optional = FALSE, ...)
    {
        .GeneSetDf_as_data_frame(x)
    }
    
    .data_frame_as_GeneSetDf <-
        function(from)
    {
        GeneSetDf(split(from$gene, from$set))
    }

    setAs("data.frame", "GeneSet", .data_frame_as_GeneSetDf)
    ```
    
4. Modify the `GeneSetDf()` constructor so that, when given a
   `data.frame` with exactly two columns `gene` and `set`, it coerces
   the `data.frame` to a `GeneSetDf`

    ```{r}
    GeneSetDf <-
        function(...)
    {
        args <- list(...)
        if (length(args) == 0L) {
            args <- list(character())
        } else if (length(args) == 1L && is.list(args)) {
            args <- args[[1]]
            test <- is.data.frame(args) && 
                setequal(names(args), c("gene", "set"))
            if (test)
                args <- split(args$gene, args$set)
        }

        .GeneSetDf(
            gene = unlist(args, use.names=FALSE),
            set = factor(
                rep(names(args), lengths(args)),
                levels = names(args)
            )
        )
    }
    ```
    
5. With the changes in the previous exercises, how well does
   `GeneSetDf()` work with the tidyverse?

6. A common file format for gene sets is `gmt`. This file has one line for each gene set; entries on the line are separated by tabs. 

   - The first element is the set identifier. 
   - The second element a set description. 
   - The third and remaining elements are the genes in the set.

   Modify the `GeneSetDf` class to contain a 'description' column. It should contain a character vector with as many elements as there are genes in a set. Modify the `show()` method.
   
7. (Advanced) Write an `import()` method for importing gmt files to `GeneSetDf` objects. The `import()` method should be based on [rtracklayer]`::import()`. This requires that you create a light-weight class `GmtFile` and an `import,GmtFile-method` that reads the file to a `GeneSetDf` object.

   Start by writing a stand-alone function that does the import
   
    ```{r}
    .import_gmt_as_GeneSetDf <-
        function(fname, ...)
    {
        raw <- readLines(fname)
        sets <- strsplit(raw, "\t")
        names <- vapply(sets, `[[`, character(1), 1)
        descriptions <- vapply(sets, `[[`, character(1), 2)
        genes <- lapply(sets, `[`, -(1:2))
        names(genes) <- names
        GeneSetDf(genes)
    }
    ```
    
   Debug the stand-alone function until it works
  
    ```{r}
    .import_gmt_as_GeneSetDf("extdata/broad_chr_subset.gmt")
    ```
  
   Wire this into the [rtracklayer][] infrastructure by defining a 'dispatch' class `GmtFile` that contains `RTLFile` ('rtracklayer file', defined in the [rtracklayer][] package).
  
    ```{r, message=FALSE}
    library(rtracklayer)

    .GmtFile <- setClass("GmtFile", contains = "RTLFile")
    
    GmtFile <-
        function(con, ...)
    {
        .GmtFile(resource = con, ...)
    }
    ```
   and an `import,GmtFile-method`
   
    ```{r}
    setMethod("import", "GmtFile", function(con, format, txt, ...) {
        .import_gmt_as_GeneSetDf(resource(con))
    })
    ```
    
   check out the result
   
    ```{r}
    import("extdata/broad_chr_subset.gmt")
    ```

8. (Advanced) Revise either the `GeneSet()` or `GeneSetDf()` interface so that both `GeneSet()` and `GeneSetDf()` have exactly the same interface, even though the implementation differs.

[rtracklayer]: https://bioconductor.org/packages/rtracklayer

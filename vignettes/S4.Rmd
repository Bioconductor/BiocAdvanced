---
title: "S4 Classes and Methods"
author: "Martin Morgan"
date: "July 31 - August 1, 2018"
vignette: >
  %\VignetteIndexEntry{S4}
  %\VignetteEngine{knitr::rmarkdown}
output: 
  BiocStyle::html_document
---

# Object systems

## S3

- Class defined by presence of a 'class' attribute
- Generic function defined by presence of `UseMethod()` as body.
- Methods defined _on the generic_.

- Loose class definition
- Linear inheritance
- Single dispatch
- Generally, no distinction between 'user' interface and 'developer'
  implementation

## S4

Formal...

- ... class definition -- `setClass()`
- ... generic definition -- `setGeneric()`
- ... method definition -- `setMethod()`

Benefits

- Programatic access to class definition
  - Complex data representations possible
  - Encourages separation of user 'API' from developer implementation
- Multiple inheritance
- Multiple dispatch

# Developing a class to represent gene sets

What is a gene set?

- A collection of gene symbols

A base _R_ representation might be

```{r}
sets <- list(
    set1 = sample(letters, 7),
    set2 = sample(LETTERS, 5)
)
```

## An S3 class and methods

S3 classes are easy to create -- simply add the `class()` attribute to the object.

```{r}
s3geneset <- sets
class(s3geneset) <- "gene_set"
names(s3geneset)
lengths(s3geneset)
```

S3 methods take a generic such as `print()` (we know it is an S3 generic because it has `UseMethod("print")` as the only content of it's body).

```{r}
print
```

and defining a new function `print.gene_set`; _R_ recognizes this form to indicate that `print.gene_set` is one of the 'next methods' that the `print()` function should look for when trying to print an object. _R_ will use `print.gene_set()` when the first argument to `print()` is an object with class `gene_set`.

```{r}
print.gene_set <- function(x) {
    cat(
        "S3 class: ", class(x), "\n",
        "names(): ", paste(names(x), collapse=" "), "\n",
        "lengths(): ", paste(lengths(x), collapse=" "), "\n",
        sep=""
    )
}

print(s3geneset)
```

Our implementation is not very robust, for instance the following breaks the expectation that genes in a set are represented by `character()` values.

```{r}
s3geneset$set1 <- sample(5)
```

# S4 class and methods: `data.frame`-like implementation

There are many different ways one could choose to represent a gene set. There can be great value in working with 'tidy'-looking data such as a long data.frame-like object. We start by defining a class to represent gene sets in a data.frame-like manner.

## Class definition

Use `setClass()` to define our class. `slots` are like 'fields' in Java / C++. We'll represent our data in a *column-oriented* fashion, rather than row-oriented -- the object represents two columns, rather than 1 row with fields `gene` and `set`. This means that a single column-oriented object can represent `n` gene sets, rather than requiring `n` row-oriented objects to represent `n` genes.

```{r}
.GeneSetDf <- setClass(
    "GeneSetDf",
    slots = c(
        gene = "character", 
        set = "factor"
    )
)
```

`setClass()` returns a kind of internal constructor that can be used to create instances of our new class. `.GeneSetDf()` is a constructor that is useful for _developers_, but not usually for users. It takes arguments named after slots, e.g.,

```{r}
.GeneSetDf(
    gene = c("A", "B", "C", "D"),
    set = factor(c("set1", "set1", "set1", "set2"))
)
```

S4 classes have formal definitions, and it is possible to discover and programmatically consult the class definition

```{r}
getClass("GeneSetDf")
```

## Accessors

It is always a good idea to write convenience functions that access the data contained in the slots. The accessors may simply access the slot directly (as below), but the abstraction provided by the function provides the developer with a great deal of flexibility in designing and implementing their class. Here are some plain-old-functions to access the `gene` and `set` slots; they start with a dot (`.`) as a convention to indicate that they are meant only for developer use.

```{r}
.GeneSetDf_gene <- function(x)
    slot(x, "gene")

.GeneSetDf_set <- function(x)
    slot(x, "set")
```

Accessors can be plain functions, or a generic with methods. Let's make them generics with methods. There are no existing generics `gene()` or `set()`, so define the generics

```{r}
setGeneric("gene", function(x) standardGeneric("gene"))

setGeneric("set", function(x) standardGeneric("set"))
```

Implement the methods using our existing plain-old-functions

```{r}
setMethod("gene", "GeneSetDf", .GeneSetDf_gene)

setMethod("set", "GeneSetDf", .GeneSetDf_set)
```

Accessors provide a layer to separate what the user interfaces with (`gene()`, `set()`) versus what the developer thinks is an efficient representation.

There are two other useful accessor-like functions. `names()` returns the gene set names, while `lengths()` returns the length of each gene set. Here are our internal definitions

```{r}
.GeneSetDf_names <- function(x)
    levels(set(x))

.GeneSetDf_lengths <-
    function(x, use.names = TRUE)
{
    lengths <- as.vector(table(set(x)))
    if (use.names)
        names(lengths) <- names(x)
    lengths
}
```

The `names()` function is a generic (see `getGeneric("names")`), so the method is easily defined

```{r}
setMethod("names", "GeneSetDf", .GeneSetDf_names)
```

`lengths()` is a plain-old-function. We promote it to a generic and implement a method

```{r}
setGeneric("lengths")

setMethod("lengths", "GeneSetDf", .GeneSetDf_lengths)
```

Discover available methods with `showMethods()`

```{r}
showMethods("gene")

showMethods(classes = "GeneSetDf", where = .GlobalEnv)
```

## Validity

Class definitions ensure each slot contains the correct _type_ of data, but there are often other constraints, e.g., that `gene` and `set` are the same length. Write a function that tests the validity of the object. The contract is: return TRUE if valid, or a character vector describing how the object is not valid.

```{r}
.GeneSetDf_validity <-
    function(object)
{
    msg <- NULL
    
    if (length(gene(object)) != length(set(object)))
        msg <- c(msg, "length of 'gene' must equal length of 'set'")
    
    if (is.null(msg)) TRUE else msg
}
```

Use `setValidity()` to associate the class with the function that tests its validity.

```{r}
setValidity("GeneSetDf", .GeneSetDf_validity)
```

## A constructor for users

`.GeneSetDf()` exposes slots directly to the caller, but usually one wants to separate the 'implementation' details (i.e., slots) from the 'interface' seen by the user. So we write a user-facing constructor that provides convenient ways to create our object.

For instance, it might be convenient if `GeneSetDf()` could be invoked with a list of named character vectors `GeneSetDf(list(set1 = letters[1:3], set2 = LETTERS[1:5}))` or with named arguments defining the gene set `GeneSetDf(set1 = letters[1:3], set2 = LETTERS[1:5])`.

This user-facing convenience does not influence the representation of the object.

```{r}
GeneSetDf <-
    function(...)
{
    args <- list(...)

    if (length(args) == 0L) {
        args <- list(character())
    } else if (length(args) == 1L && is(args, "list"))
        args <- args[[1]]

    .GeneSetDf(
        gene = unlist(unname(args)),
        set = factor(
            rep(names(args), lengths(args)),
            levels = names(args)
        )
    )
}
```

## A `show,GeneSetDf-method`

`show()` is a generic that has as it's contract to print the object. `show()` is an existing generic (see `getGeneric("show")`). Since genomic data are usually large, we try to implement a `show()` method that is not overwhelmed by large data.

```{r}
setMethod(
    "show", "GeneSetDf",
    function(object)
{
    cat("class: ", class(object), "\n",
        "names(): ", paste(names(object), collapse = " "), "\n",
        "lengths(): ", paste(lengths(object), collapse = " "), "\n",
        sep = ""
    )
})
```

Here's our interface in action...

```{r}
gs <- GeneSetDf(sets)
gs
gene(gs)
set(gs)
```

# S4 class and method: `list`-like implementation

There is usually more than one way to represent data. Here's a different implementation based on lists. It's worth thinking about the pros and cons of this implementation. Since the implementation is a detail meaningful to the developer, it is possible to switch implementations _without_ changing the user-facing interface. We do this to some extent here.

## Class definition

The `GeneSet` class is very simple -- it 'contains' (extends) `list`, i.e., the gene sets will be represented as lists of character vectors.

```{r}
.GeneSet <- setClass(
    "GeneSet",
    contains = "list"
)
```

## Accessors

We could write accessors for this class, too, even though there are no `gene` or `set` slots.

```{r}
setMethod("gene", "GeneSet", function(x) unlist(x, use.names = FALSE))

setMethod(
    "set", "GeneSet",
    function(x)
{
    set <- rep(names(x), lengths(x))
    factor(set, levels = names(x))
})
```

Inheritance from the contained 'list' representation gives us `names()` and `lengths()` without any additional code!

## Validity

We need to ensure that all elements of the list are `character()`, that all list elements are named, and that there are no identically named gene sets.

```{r}
.GeneSet_validity <- function(object) {
    msg <- NULL

    types <- vapply(object, is, logical(1), "character")
    if (!all(types))
        msg <- c(msg, "'GeneSet' members must be character()")

    if (sum(nzchar(names(object))) != length(object))
        msg <- c(msg, "Each 'GeneSet' must be named")

    if (any(duplicated(names(object))))
        msg <- c(msg, "'GeneSet' names must be unique")

    if (is.null(msg)) TRUE else msg
}

setValidity("GeneSet", .GeneSet_validity)
```

## A constructor for users

Our user-facing contructor will accept either a list of gene sets, or a series of named arguments, each representing a gene set.

```{r}
GeneSet <-
    function(...)
{
    args <- list(...)

    if (length(args) == 1L && is(args[[1]], "list"))
        args <- args[[1]]

    .GeneSet(args)
}
```

## A `show,GeneSet-method`

The `show,GeneSet-method` presents the data in the same way as the `show,GeneSetDf-method`. The interface, from the user perspective, is the same between the two different classes. The implementation, from the developer perspective, is the same.

```{r}
setMethod(
    "show", "GeneSet",
    function(object)
{
    cat(
        "class: ", class(object), "\n",
        "names(): ", paste(names(object), collapse=" "), "\n",
        "lengths(): ", paste(lengths(object), collapse=" "), "\n",
        sep=""
    )
})
```

Here's our interface so far; the user interacts with this class in exactly the same way as for `GeneSetDf`, even though the classes are implemented in very different ways.

```{r}
GeneSet(sets)
GeneSet(A = letters[1:4], B = LETTERS[1:3])
gs <- GeneSet(sets)
gs
gene(gs)
set(gs)
```

## Subsetting and update: `[`, `[[`, `[<-`, `[[<-`

The list-like definition of `GeneSet` suggest that we would like to be able to implement other aspects of the 'list' interface, especially `[` and `[[` subsetting and updating.

Note that the default `[` does not work quite as we would like -- it returns a list, rather than a `GeneSet`

```{r}
gs[1]   ## list, rather than GeneSet
```

We address this by writing a new method for `[`. Here's the generic

```{r}
getGeneric("[")
```

Note the signature of the generic, and that there are _four_ arguments that can be dispatched on. Here's one definition of the `[,GeneSet-method`.

```{r}
setMethod(
    "[", c("GeneSet", "ANY", "missing", "missing"),
    function(x, i, j, ..., drop = TRUE)
{
    result <- callNextMethod()
    result <- as(result, "GeneSet")
    validObject(result)
    result
})
```

And we can see that `[` now returns a `GeneSet`

```{r}
gs[1]
gs[c("set2", "set1")]
```

The default `[[` method works fine for our purposes, so we do not need to implement a method.

```{r}
gs[[1]]
gs[["set2"]]
```

The next task is to write a _replacement_ method. This method will update the value of the object. Here's the generic, again with four arguments in its signature.

```{r}
getGeneric("[<-")
```

The `setReplaceMethod()` function is used to implement the method:

```{r}
setReplaceMethod(
    "[", signature = c("GeneSet", "ANY", "missing", "ANY"),
    function(x, i, j, ..., value)
{
    if (length(i) != length(value))
        stop("'GeneSet' replacement value length not equal to length(i)")
    if (any(nzchar(names(value))) && !all(names(x)[i] == names(value)))
        stop("'GeneSet' replacement names do not equal GeneSet names")

    result <- callNextMethod()
    validObject(result)

    result
})
```

Here's the replacement method in action, updating the value of the gene set

```{r}
gs1 <- gs2 <- gs
gs1[2] <- list(LETTERS[5:10])
gs1[[2]]
gs2[[2]]
```

We'd also like to be able to update individual sets using `[[<-`.

```{r}
setReplaceMethod(
    "[[", signature = c("GeneSet", "ANY", "missing", "ANY"),
    function(x, i, j, ..., value)
{
    result <- callNextMethod()
    result <- as(result, "GeneSet")
    validObject(result)
    result
})
```

## Coercion

_Coercion_ methods enable commands like `as(gs, "data.frame")`. These special methods are defined using `setAs()`. For example, we write a function that will coerce a `GeneSet` to a `data.frame`.

```{r}
.GeneSet_as_data_frame <-
    function(from)
{
    data.frame(
        gene = unlist(unname(from)),
        set = factor(
            rep(names(from), lengths(from)), 
            levels = names(from)
        ),
        stringsAsFactors = FALSE
    )
}
```

We then implement S4 functionality for `as(gs, "data.frame")`

```{r}
setAs("GeneSet", "data.frame", .GeneSet_as_data_frame)
```

and for convenience implement `as.data.frame(gs)` using the same helper function

```{r}
as.data.frame.GeneSet <- 
    function(x, row.names = NULL, optional = FALSE, ...)
{
    .GeneSet_as_data_frame(x)
}
```

# Exercises

1. Improve the `show()` method for `GeneSet` so that the first
   several genes of the first several sets are displayed
   
    ```{r}
    .select_some <-
        function(x, n = 6)
    {
        if (length(x) > n)
            x <- c(head(x, n - 1), "...")
        paste(x, collapse = " ")
    }
    
    setMethod(
        "show", "GeneSet",
        function(object)
    {
        cat(
            "class: ", class(object), "\n",
            "length(): ", length(object), "\n",
            "names(): ", paste(names(object), collapse=" "), "\n",
            "lengths(): ", paste(lengths(object), collapse=" "), "\n",
            sep=""
        )
        for (i in seq_len(min(length(object), 6)))
            cat(
                '[["', names(object)[i], '"]]: ',
                    .select_some(object[[i]]), "\n",
                sep = ""
            )
        if (length(object) > 6)
            cat("...\n")
    })
    ```

2. Improve the `show()` method for `GeneSetDf` to print the first
   several genes of the first several sets in a data.frame-like format,

    ```
    gene    set
       a   set1
       b   set1
       c   set1
     ...    ...
       A   set2
       B   set2
       C   set2
     ...    ...
     ...    ...
    ```

3. Write `setAs()` methods to coerce a `GeneSetDf` to and from a `data.frame`

    ```{r}
    .GeneSetDf_as_data_frame <-
        function(from)
    {
        data.frame(
            gene = gene(from), set = set(from), 
            stringsAsFactors = FALSE
        )
    }
    
    as.data.frame.GeneSetDf <- 
        function(x, row.names = NULL, optional = FALSE, ...)
    {
        .GeneSetDf_as_data_frame(x)
    }
    
    .data_frame_as_GeneSetDf <-
        function(from)
    {
        GeneSetDf(split(from$gene, from$set))
    }

    setAs("data.frame", "GeneSet", .data_frame_as_GeneSetDf)
    ```
    
4. Modify the `GeneSetDf()` constructor so that, when given a
   `data.frame` with exactly two columns `gene` and `set`, it coerces
   the `data.frame` to a `GeneSetDf`

    ```{r}
    GeneSetDf <-
        function(...)
    {
        args <- list(...)
        if (length(args) == 0L) {
            args <- list(character())
        } else if (length(args) == 1L && is.list(args)) {
            args <- args[[1]]
            test <- is.data.frame(args) && 
                setequal(names(args), c("gene", "set"))
            if (test)
                args <- split(args$gene, args$set)
        }

        .GeneSetDf(
            gene = unlist(args, use.names=FALSE),
            set = factor(
                rep(names(args), lengths(args)),
                levels = names(args)
            )
        )
    }
    ```
    
5. With the changes in the previous exercises, how well does
   `GeneSetDf()` work with the tidyverse?

6. A common file format for gene sets is `gmt`. This file has one line for each gene set; entries on the line are separated by tabs. 

   - The first element is the set identifier. 
   - The second element a set description. 
   - The third and remaining elements are the genes in the set.

   Modify the `GeneSetDf` class to contain a 'description' column. It should contain a character vector with as many elements as there are genes in a set. Modify the `show()` method.
   
7. (Advanced) Write an `import()` method for importing gmt files to `GeneSetDf` objects. The `import()` method should be based on [rtracklayer]`::import()`. This requires that you create a light-weight class `GmtFile` and an `import,GmtFile-method` that reads the file to a `GeneSetDf` object.

   Start by writing a stand-alone function that does the import
   
    ```{r}
    .import_gmt_as_GeneSetDf <-
        function(fname, ...)
    {
        raw <- readLines(fname)
        sets <- strsplit(raw, "\t")
        names <- vapply(sets, `[[`, character(1), 1)
        descriptions <- vapply(sets, `[[`, character(1), 2)
        genes <- lapply(sets, `[`, -(1:2))
        names(genes) <- names
        GeneSetDf(genes)
    }
    ```
    
   Debug the stand-alone function until it works
  
    ```{r}
    .import_gmt_as_GeneSetDf("extdata/broad_chr_subset.gmt")
    ```
  
   Wire this into the [rtracklayer][] infrastructure by defining a 'dispatch' class `GmtFile` that contains `RTLFile` ('rtracklayer file', defined in the [rtracklayer][] package).
  
    ```{r, message=FALSE}
    library(rtracklayer)

    .GmtFile <- setClass("GmtFile", contains = "RTLFile")
    
    GmtFile <-
        function(con, ...)
    {
        .GmtFile(resource = con, ...)
    }
    ```
   and an `import,GmtFile-method`
   
    ```{r}
    setMethod("import", "GmtFile", function(con, format, txt, ...) {
        .import_gmt_as_GeneSetDf(resource(con))
    })
    ```
    
   check out the result
   
    ```{r}
    import("extdata/broad_chr_subset.gmt")
    ```

8. (Advanced) Revise either the `GeneSet()` or `GeneSetDf()` interface so that both `GeneSet()` and `GeneSetDf()` have exactly the same interface, even though the implementation differs.

[rtracklayer]: https://bioconductor.org/packages/rtracklayer

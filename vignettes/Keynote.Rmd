---
title: "Keynote: Bioconductor for high-throughput genomic analysis"
author: "Martin Morgan"
date: "July 31 - August 1, 2018"
vignette: >
  %\VignetteIndexEntry{Keynote}
  %\VignetteEngine{knitr::rmarkdown}
output: 
  BiocStyle::html_document
---

```{r style, echo = FALSE, results = 'asis'}
knitr::opts_chunk$set(
    eval=as.logical(Sys.getenv("KNITR_EVAL", "TRUE")),
    cache=as.logical(Sys.getenv("KNITR_CACHE", "TRUE")))
```

# Introduction to _Bioconductor_

_Bioconductor_ is a collection of more than 1,500 packages for the statistical analysis and comprehension of high-throughput genomic data. Originally developed for microarrays, _Bioconductor_ packages are now used in a wide range of analyses, including bulk and single-cell RNA-seq, ChIP seq, copy number analysis, microarray methylation and classic expression analysis, flow cytometry, and many other domains. 

This section of the workshop introduces the essential of _Bioconductor_ package discovery, installation, and use. Get the material from [https://github.com/Bioconductor/BiocAdvanced][]

[https://github.com/Bioconductor/BiocAdvanced]: https://github.com/Bioconductor/BiocAdvanced

# Discovering, installing, and learning how to use _Bioconductor_ packages

**Discovery**

The web site at https://bioconductor.org contains descriptions of all _Bioconductor_ packages, as well as essential reference material for all levels of user.

Packages available in _Bioconductor_ are summarized at [https://bioconductor.org/packages][], also linked from the front page of the web site. The widget on the left summarizes four distinct types of _Bioconductor_ packages

- 'Software' packages implement particular analyses or other functionality, e.g., querying web-based resources or importing common file formats to _Bioconductor_ objects.

- 'Annotation' packages contain data that can be helpful in placing analysis results in context, for example: mapping between gene symbols such as "BRCA1" and Ensembl or Entrez gene identifiers; classifying genes in terms of gene ontology; describing the genomic coordinates of exons, transcripts, and genes; and representing whole genome sequences of common organisms.

- 'Experiment data' packages contain highly curated data sets that can be useful for learning and teaching (e.g., the [airway][] package and data set used in the [DESeq2][] package for the analysis of bulk RNA-seq differential expression) or placing results in context (e.g., the [curatedTCGAData][] package for conveniently accessing TCGA data in a way that allows very smooth integeration into _Bioconductor_ analyses).

- 'Workflow' packages that summarize common work flows, e.g., [simpleSingleCell][] for single-cell RNA-seq expression analysis.

[airway]: https://bioconductor.org/packages/airway
[DESeq2]: https://bioconductor.org/packages/DESeq2
[curatedTCGAData]: https://bioconductor.org/packages/curatedTCGAData
[simpleSingleCell]: https://bioconductor.org/packages/simpleSingleCell

**Installation**

Like CRAN packages, _Bioconductor_ packages need to be installed only once per _R_ installation, and then attached to each session where they are going to be used.

_Bioconductor_ packages are installed slightly differently from CRAN packages. The first step is to install the [BiocManager][] package from CRAN.

```{r, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager", repos="https://cran.r-project.org")
```

The next step is to install the desired _Bioconductor_ packages. The syntax to install the [rtracklayer][] and [GenomicRanges][] packages is

```{r, eval = FALSE}
BiocManager::install(c("rtracklayer", "GenomicRanges"))
```

_Bioconductor_ packages tend to depend on one another quite alot, so it is important that the correct versions of all packages are installed. Validate your installation (not necessary during the course) with

```{r, eval = FALSE}
BiocManager::valid()
```

A convenient function in [BiocManager][] is `available()`, which accepts a regular expression to find matching packages. The following finds all 'TxDb' packages (describing exon, transcript, and gene coordinates) for _Homo sapiens_.

```{r}
BiocManager::available("TxDb.Hsapiens")
```

[BiocManager]: https://cran.r-project.org/package=BiocManager

**Learning and support**

Each package is linked to a 'landing page', e.g., [DESeq2][] that contains a description of the package, authors, perhaps literature citations where the software is described, and installation instructions.

An important part of _Bioconductor_ packages are 'vignettes' which describe how the package is to be used. Vignettes are linked from package landing pages, and are available from within _R_ using

```{r, eval = FALSE}
browseVignettes("simpleSingleCell")
```

Users can get support on using packages at https://support.bioconductor.org, a question-and-answer style forum where response usually come quickly and often from very knowledgable users or the package developer. There are many additional sources of support, including [course material][] linked from the home page.

[https://bioconductor.org/packages]: https://bioconductor.org/packages
[work flows]: https://bioconductor.org/packages/release/BiocViews.html#___Workflow
[course material]: https://bioconductor.org/help/course-materials

# Working with Genomic Ranges

This section introduces two useful packages for general-purpose work on genomic coordinates. The [rtracklayer][] package provides the `import()` function to read many types of genomic files (e.g., BED, GTF, VCF, FASTA) into _Bioconductor_ objects. The [GenomicRanges][] package provides functions for manipulating genomic ranges, i.e., descriptions of exons, genes, ChIP peaks, called variants, ... as coordinates in genome space.

Start by attaching the [rtracklayer][] and [GenomicRanges][] packages to our session.

```{r, message=FALSE}
library("rtracklayer")
library("GenomicRanges")
```

**Importing data**

We'll read in a BED file derived from the UCSC genome browser. The file contains the coordinates of all CpG islands in the human genome, and is described at the [UCSC table browser][]. Here are the first few lines of the file, giving the chromosme, start and end coordinates, and identifier of each CpG island.

[UCSC table browser]: https://genome.ucsc.edu/cgi-bin/hgTables?hgsid=578954849_wF1QP81SIHdfr8b0kmZUOcsZcHYr&clade=mammal&org=Human&db=hg38&hgta_group=regulation&hgta_track=knownGene&hgta_table=0&hgta_regionType=genome&position=chr9%3A133252000-133280861&hgta_outputType=primaryTable&hgta_outFileName=

```
chr1	155188536	155192004	CpG:_361
chr1	2226773	2229734	CpG:_366
chr1	36306229	36307408	CpG:_110
chr1	47708822	47710847	CpG:_164
chr1	53737729	53739637	CpG:_221
chr1	144179071	144179313	CpG:_20
```

Use `file.choose()` to find the file

```{r, eval = FALSE}
fname <- file.choose()   # CpGislands.Hsapiens.hg38.UCSC.bed
```

```{r, echo = FALSE}
fname <- "extdata/CpGislands.Hsapiens.hg38.UCSC.bed"
```

```{r}
fname
file.exists(fname)
```

Then use `import()` from [rtracklayer][] to read the data into _R_. The end result is a `GenomicRanges` object describing each CpG island.

```{r}
cpg <- import(fname)
cpg
```

Closely compare the coordinates of the first few ranges from the file with the first few ranges in the _Bioconductor_ representation. The [BED format][] specification says that coordinates are 0-based, and intervals are half-open (the 'start' coordinate is in the range, the 'end' coordinate is immediately after the range; this makes some computations easy). _Bioconductor_'s convention is that coordinates are 1-based and closed (i.e., both start and end coordinates are included in the range). [rtracklayer][]'s `import()` function has adjusted coordinates to follow _Bioconductor_ conventions.

[BED format]: https://genome.ucsc.edu/FAQ/FAQformat.html#format1

**Working with genomic ranges**

For convenience and to illustrate functionality, let's work only with the 'standard' chromosomes 1 - 22 autosomal, X, and Y chromosomes. Look up the help page `?keepStandardChromosomes` for an explanation of `pruning.mode=`.

```{r}
cpg <- keepStandardChromosomes(cpg, pruning.mode = "coarse")
cpg
```

There are two parts to a `GenomicRanges` object. The `seqnames` (chromosomes, in the present case), start and end coordinates, and strand are _required_. Additional elements such as `name` in the current example are optional.
Required components are accessed by functions such as `start()`, `end()` and `width()`. Optional components can be accessed using the `$` notation.

```{r}
head( start(cpg) )
head( cpg$name )
```

Use the `width()` accessor function to extract a vector of widths of each CpG island. Transform the values using `log10()`, and visualize the distribution using `hist()`.

```{r}
hist(log10(width(cpg)))
```

Use `subset()` to select the CpG islands on chromosomes 1 and 2.

```{r}
subset(cpg, seqnames %in% c("chr1", "chr2"))
```

**Genomic annotations**

Earlier we mentioned 'Annotation data' packages. An example is the TxDb.* family of packages. These packages contain information on the genomic coordinates of exons, genes, transcripts, etc. Attach the TxDb package corresponding to the _Homo sapiens_ hg38 genome build using the UCSC 'knownGene' track.

```{r, message=FALSE}
library("TxDb.Hsapiens.UCSC.hg38.knownGene")
```

Extract the coordinates of all transcripts

```{r}
tx <- transcripts(TxDb.Hsapiens.UCSC.hg38.knownGene)
tx
```

Keep only the standard chromosomes, to work smoothly with our `cpg` object.

```{r}
tx <- keepStandardChromosomes(tx, pruning.mode="coarse")
tx
```

**Overlaps**

A very useful operation is to count overlaps in two distinct genomic ranges objects. The following counts the number of CpG islands that overlap each transcript. Related functions include `findOverlaps()`, `nearest()`, `precede()`, and `follow()`.

```{r}
olaps <- countOverlaps(tx, cpg)
length(olaps)     # 1 count per transcript
table(olaps)
```

Calculations such as `countOverlaps()` can be added to the `GRanges` object, tightly coupling derived data with the original annotation.

```{r}
tx$cpgOverlaps <- countOverlaps(tx, cpg)
tx
```

It is then possible to perform coordinated actions, e.g., subsetting the `GRanges` objects for transcripts satisfying particular conditions, in a coordinated fashion where the software does all the book-keeping to makes sure the correct ranges are selected.

```{r}
subset(tx, cpgOverlaps > 10)
````

Can you think of other situations where one might calculate derived values and couple these with `GRanges` or similar objects?

# Working with summarized experimental data

This section introduces another broadly useful package and data structure, the [SummarizedExperiment][] package and `SummarizedExperiment` object. 

![](figures/SummarizedExperiment.png)

The `SummarizedExperiment` object has matrix-like properties -- it has two dimensions and can be subset by 'rows' and 'columns'. The `assay()` data of a `SummarizedExperiment` experiment contains one or more matrix-like objects where rows represent features of interest (e.g., genes), columns represent samples, and elements of the matrix represent results of a genomic assay (e.g., counts of reads overlaps genes in each sample of an bulk RNA-seq differential expression assay.

**Object construction**

The `SummarizedExperiment` coordinates assays with (optional) descriptions of rows and columns. We start by reading in a simple `data.frame` describing 8 samples from an RNASeq experiment looking at dexamethasone treatment across 4 human smooth muscle cell lines; use `browseVignettes("airway")` for a more complete description of the experiment and data processing. Read the column data in using `file.choose()` and `read.csv()`.

```{r, eval=FALSE}
fname <- file.choose()  # airway_colData.csv
fname
```

```{r, echo=FALSE}
fname <- "extdata/airway_colData.csv"
```
We want the first column the the data to be treated as row names (sample identifiers) in the `data.frame`, so `read.csv()` has an extra argument to indicate this.

```{r}
colData <- read.csv(fname, row.names = 1)
colData
```

The data are from the Short Read Archive, and the row names, `SampleName`, `Run`, `Experiment`, `Sampel`, and `BioSample` columns are classifications from the archive. Additional columns include:

- `cell`: the cell line used. There are four cell lines.
- `dex`: whether the sample was untreated, or treated with dexamethasone.
- `albut`: a second treatment, which we ignore
- `avgLength`: the sample-specific average length of the RNAseq reads estimated in the experiment.

**Assay data**

Now import the assay data from the file "airway_counts.csv"

```{r, eval=FALSE}
fname <- file.choose()  # airway_counts.csv
fname
```

```{r, echo=FALSE}
fname <- "extdata/airway_counts.csv"
```

```{r}
counts <- read.csv(fname, row.names=1)
```

Although the data are read as a `data.frame`, all columns are of the same type (integer-valued) and represent the same attribute; the data is really a `matrix` rather than `data.frame`, so we coerce to matrix using `as.matrix()`.

```{r}
counts <- as.matrix(counts)
```

We see the dimensions and first few rows of the counts matrix

```{r}
dim(counts)
head(counts)
```

It's interesting to think about what the counts mean -- for ENSG00000000003, sample SRR1039508 had 679 reads that overlapped this gene, sample SRR1039509 had 448 reads, etc. Notice that for this gene there seems to be a consistent pattern -- within a cell line, the read counts in the untreated group are always larger than the read counts for the treated group. This and other basic observations from 'looking at' the data motivate many steps in a rigorous RNASeq differential expression analysis.

**Creating a `SummarizedExperiment` object**

We saw earlier that there was considerable value in tightly coupling the count of CpG islands overlapping each transcript with the `GRanges` describing the transcripts. We can anticipate that close coupling of the column data with the assay data will have similar benefits, e.g., reducing the chances of bookkeeping errors as we work with our data.

Attach the [SummarizedExperiment][] library to our _R_ session.

```{r, message=FALSE}
library("SummarizedExperiment")
```

Use the `SummarizedExperiment()` function to coordinate the assay and column data; this function uses row and column names to make sure the correct assay columns are desribed by the correct column data rows.

```{r}
se <- SummarizedExperiment(assay = list(count=counts), colData = colData)
se
```

It is straight-forward to use `subset()` on `SummarizedExperiment` to create subsets of the data in a coordinated way. Remember that a `SummarizedExperiment` is conceptually two-dimensional (matrix-like), and in the example below we are subsetting on the second dimension.

```{r}
subset(se, , dex == "trt")
```

As with `GRanges`, there are accessors that extract data from the `SummarizedExperiment`. For instance, we can use `assay()` to extract the count matrix, and `colSums()` to calculate the library size (total number of reads overlapping genes in each sample).

```{r}
colSums(assay(se))
```

Note that library sizes differ by a factor of 2 from largest to smallest; how would this influence the interpretation of counts in individual cells of the assay data?

As with `GRanges`, it might be useful to remember important computations in a way that is robust, e.g., 

```{r}
se$lib.size <- colSums(assay(se))
colData(se)
```

# Down-stream analysis

In this final section we quickly hint at down-stream analysis, and the way in which skills learned in working with _Bioconductor_ objects in one package translate to working with objects in other packages.

We start by loading the [DESeq2][] package, a very popular facility for analysing bulk RNAseq differential experssion data.

```{r, message=FALSE}
library("DESeq2")
```

The package requires count data like that in the `SummarizedExperiment` we have been working with, in addition to a `formula` describing the experimental design. Some of the observations above suggest that we should include cell line as a covariate, and dexamethazone treatment as the main factor that we are interested in.

```{r}
dds <- DESeqDataSet(se, design = ~ cell + dex)
dds
```

The `dds` object can be manipulated very much like a `SummarizedExperiment`.

The essention DESeq work flow is summarized by a single function call, which performs advanced statistical analysis on the data in the `dds` object.

```{r}
dds <- DESeq(dds)
```

A table summarizing measures of differential expression can be extracted from the object, and visualized or manipulated using commands we learned earlier today.

```{r}
results(dds)
```

# End matter

```{r}
sessionInfo()
```

[GenomicRanges]: https://bioconductor.org/packages/GenomicRanges
[rtracklayer]: https://bioconductor.org/packages/rtracklayer
[SummarizedExperiment]: https://bioconductor.org/packages/SummarizedExperiment

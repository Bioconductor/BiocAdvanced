---
title: "Inside the mind of _R_"
author: "Martin Morgan, Herve Pages"
date: "June 19 - 20, 2017"
vignette: >
  %\VignetteIndexEntry{Inside the mind of R}
  %\VignetteEngine{knitr::rmarkdown}
output:
  BiocStyle::html_document
---

# _R_ as we know it

## Memory management

Copy on change

- It seems like _R_ variables do not share any memory

    ```{r}
    x <- y <- 1:5
    x
    y
    x[1] <- 2L
    x
    y
    ```

    ```{r}
    x <- 1:5
    fun = function(z) { z[1] = 2L; z }
    fun(x)
    x
    ```

    - Different from many programming languages
    - Very convenient for users -- they don't have to think about
      'change-at-a-distance'.
- _R_ uses a 'named' concept, rather than strict 'reference counting'

    - Counts the number of references to a location in memory...
    - But can only count to 2
    - So '2' means that at some point in the memory location's
      history, 2 _or more_ symbols referenced that location.
- In action

    ```{r}
    x = 1:5
    .Internal(inspect(x))
    ```

    - `@41de7d8`: memory address.
    - `13 INTSXP`: integer 'S-expression' (more later).
    - `[NAM(1)]`: One symbol (`x`) references the location in memory.

    ```{r}
    x = y = 1:5
    .Internal(inspect(x))
    .Internal(inspect(y))
    ```

    - `x`, `y` point to same location in memory
    - `[NAM(2)]`: (at least) two symbols reference the location

- 'Copy-on-change': when updating a vector, make a copy if `NAM() == 2`.

    ```{r}
    ## copy on change
    x = y = 1:5
    .Internal(inspect(x))
    x[1] = 2L
    .Internal(inspect(x))
    .Internal(inspect(y))

    ## no copy necessary
    x = 1:5
    .Internal(inspect(x))
    x[1] = 2L
    .Internal(inspect(x))

    ```

Garbage collection (approximate description)

- S-expressions (`SEXP`) allocated by the system to a pool of
  available S-expressions
- `x <- 1` moves the SEXP from allocated to 'in use' pool, level 0
  (the 0 in `g0c4` of `.Internal(inspect(x))`)
- After `rm(x)`, a symbol no longer references the SEXP and it is a
  candidate for re-use.
- `gc()` (manual, or more typically triggered automatically when _R_
  runs out of SEXP in the available pool)

    - Visits all SEXP in g0 pool and marks as 'unreferenced'
    - Visits all symbols in use and marks their SEXP as 'in use'
    - Visits (second time) all SEXP in g0 pool. Moves unreferenced
      symbols to the 'available' pool, moves 'in use' to the g1 pool.

- Note: SEXP belong to 'generations' and classes

    ```{r}
    y = 1
    fun = function() { x <- 1; 2 }
    fun(); gc()    # scans x, y; collects x, ages y
    fun(); gc()    # scans & collects x, does not visit y
    ```

    - g0 generation are recently allocated, and checked for
      suitability for garbage collection most frequently -- typically
      symbols allocated in functions and no longer in scope; ripe for
      collection.
    - g1 has survived increasingly many garbage collections -- package
      or globals symbols that seldom become eligible for collection.
    - Net effect: g0 nodes enriched for SEXP that can collected.

- Resources: _R_ Internals manual e.g., the
  [write barrier][R-ints-gc], Luke Tierney's [notes][gc-notes];
  [memory.c][].

[gc-notes]: http://homepage.stat.uiowa.edu/~luke/R/gengcnotes.html
[R-ints-gc]: https://cran.r-project.org/doc/manuals/r-devel/R-ints.html#The-write-barrier
[memory.c]: https://github.com/wch/r-source/blob/trunk/src/main/memory.c

Performance consequences

- Allocation and copying are comparatively expensive
- Some common use patterns involve a lot of copying!

    - `c()`, `rbind()`, `cbind()` in a loop
    - Modifying a `data.frame()`, `list()`, or S4 object.

### Exercises

Use `.Internal(inspect())` to follow memory allocated to `x` in the
following loop.

```{r}
x <- integer()
n <- 5
for (i in 1:n)
    x <- c(x, i)
```

<!--
```{r, eval = FALSE}
x = 1L; .Internal(inspect(x))
for (i in 1:n) {
    x <- c(x, i)
    .Internal(inspect(x))
}
```
-->

- If an integer occupies about 8 bytes of memory, and each iteration
  in the loop copies the current allocation into the new allocation,
  how many bytes are copied in a loop with `n` iterations?

- Interpret the output of `tracemem()` for memory allocations when
  updating a value in a `data.frame()`. How much of the `data.frame`
  is being copied?

    ```{r}
    df <- mtcars
    tracemem(df)        # The overall data.frame
    tracemem(df[[1]])   # The specific column
    df[1, 1]
    df[1, 1] = 22.1
    df[2, 2] = 22.2
    ```

- Compare this to memory allocations when modifying a similarly sized matrix

    ```{r}
    m <- m1 <- matrix(0, nrow(mtcars), ncol(mtcars))
    tracemem(m)         # A matrix is a vector with dims attributes
    m[1, 1] = 22.1
    m[2, 1] = 22.2
    ```

-  And to a 'vectorized' update

    ```{r}
    df <- mtcars
    tracemem(df); tracemem(df[[1]])
    df[1:2, 1] <- c(22.1, 22.2)

    m <- m1 <- matrix(0, nrow(mtcars), ncol(mtcars))
    tracemem(m)         # A matrix is a vector with dims attributes
    m[1:2, 1] <- c(22.1, 22.2)
    ```

## Correct, robust, fast: practical techniques

Here's a simple function, implemented poorly

```{r}
f <- function(n) {
    x <- integer()
    for (i in 1:n)
        x <- c(x, i)
    x
}
```

Correct

- Most important!
- `identical()` -- very strict
- `all.equal()` -- allows for numerical approximation
- Unit tests!

    ```{r}
    library(testthat)
    test_that("f() is correct", {
        expect_identical(f(5), 1:5)
    })
    ```

Robust

- Edge cases, e.g., length 0 iterations, `NA` values, ... Here we add
  some additional tests, and put them in a function for easy reuse.

    ```{r}
    tests <- function(f) {
        test_that("f() is correct", {
            expect_identical(f(5), 1:5)
            expect_identical(f(1), 1L)
            expect_identical(f(0), integer(0))
        })
    }
    ```

- Our code fails the unit tests, because `1:n` fails with `n == 0`

    ```{r}
    tryCatch(tests(f), error = conditionMessage)
    ```

- Revised code, robust to common use case

    ```{r}
    f1 = function(n) {
        x <- integer()
        for (i in seq_len(n))
            x = c(x, i)
        x
    }
    tests(f1)
    ```

Fast

- `system.time()`, but can be considerable run-to-run variation
- [microbenchmark][]

    ```{r}
    library(microbenchmark)
    res <- microbenchmark(f1(100), f1(200), f1(400), f1(800), f1(1600))
    plot(res)
    ```

- Scales quadratically, because of copying. Solutions?

    ```{r, eval=FALSE}
    f2 <- function(n) {
        sapply(seq_len(n), function(i) i)
    }
    tests(f2)  # fails! n == 0
    ```

    ```{r, eval=FALSE}
    f2a <- function(n) {
        if (n == 0) {
            integer()
        } else {
            sapply(seq_len(n), function(i) i)
        }
    }
    tests(f2a)
    ```

    ```{r, eval=FALSE}
    f3 <- function(n) {
        vapply(seq_len(n), function(i) i, integer(1))
    }
    test_that("f() is correct", {
        expect_identical(f3(5), 1:5)
        expect_identical(f3(1), 1L)
        expect_identical(f3(0), integer(0))
    })
    tests(f3)
    ```

    ```{r, eval=FALSE}
    f4 <- function(n) {
        x <- integer(n)
        for (i in seq_len(n))
            x[[i]] = i
        x
    }
    tests(f4)
    ```

    ```{r, eval=FALSE}
    f5 <- seq_len
    tests(f5)
    ```

    ```{r, eval=FALSE}
    n <- 1000
    microbenchmark(f1(n), f2a(n), f3(n), f4(n), f5(n))
    ```

## Symbol resolution and evaluation

Environments

- Current environment

    ```{r}
    environment()
    ```

- surprisingly central to _R_

    ```{r}
    env <- new.env()
    env[["foo"]] <- 123
    env[["foo"]]
    get("foo", env)      # equivalent (not really!)
    ls(env)
    ```

- hash table of key-value pairs
  - Key is called a `name` or `symbol` in _R_
  - constant-time lookup

- 'reference' semantics (almost all else in _R_ is 'copy-on-change' semantics)

    ```{r}
    another <- env
    env[["bar"]] <- 456
    another[["bar"]]
    ```
- All environments have a 'parent' environment

    ```{r}
    parent.env(env)
    ```

    - special environment: `emptyenv()`
    - parent environment is set during construction (argument to `new.env()`)

- Environment can be chained together as a linked list

    ```{r}
    top <- new.env(parent = emptyenv())
    mid <- new.env(parent = top)
    bot <- new.env(parent = mid)
    ```

- Symbol (key) look-up

    ```{r}
    top[["top"]] <- 1
    mid[["mid"]] <- 2
    bot[["bot"]] <- 3
    ```

- Symbols not found in the reference enviroment are looked for in the
  parent environment

    ```{r}
    get("bot", bot)
    get("mid", bot)
    tryCatch({
        get("mid", bot, inherits=FALSE) # restricts search to current env
    }, error = conditionMessage)
    bot[["mid"]]                        # NULL; `[[` restricts to current env
    ```

- Assignment is to the current environment

    ```{r}
    bot[["mid"]] <- 5
    bot[["mid"]]
    mid[["mid"]]
    ```

- Functions are intimately connected to environments

    ```{r}
    fun <- function() {
        environment()
    }
    fun()              # an environment defines the body of a function
    fun()              # new function, so new environment
    ```

- What happens to the environment in a function?

    - garbage collection (later!) when no longer referenced

- If a function body has an environment, there must be a parent environment

    ```{r}
    fun <- function() {
        env <- environment()
        list(env, parent.env(env))
    }
    fun()
    ```

    - Is the parent of the environment of a function the environment
      in which the function was _called from_, or the environment in
      which the function was _defined_?

    ```{r}
    fun <- function() {
        fun1 <- function() {
            env1 <- environment()    # envrionment created by fun1
            par1 <- parent.env(env1) # parent environment
            list(env1 = env1, par1 = par1)
        }
        env <- environment()        # environment created by fun
        par <- parent.env(env)
        list(env = env, par = par, fun1=fun1)
    }
    fun()
    ```

    - The parent of a function's environment is the environment _in
      which it was defined_ (different from the environment from which
      it was called)

    - Lookup, assignment (`<-`) and assignment to the parent(s)
      environment (`<<-`)

    ```{r}
    fun = function() {
        x0 <- 0
        x1 <- 0
        fun1 <- function() {
            y <- 1     # create local variable y
            x1 <<- 2   # assign to first occurrence of 'x' in parent env(s)
            z <<- 3    # no z in parent env(s), so created in top env
            c(x0 = x0, x1 = x1, y = y, z = z)
        }

        result <- fun1()
        list(x0 = x0, x1 = x1, result = result)
    }
    ```

- This is called **[lexical scope][]**

[lexical scope]: https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf

- When is lexical scope used?


Package namespaces, imports, and `search()`

- The `search() path

    ```{r}
    search()
    ```

- `library(BiocGenerics)`: loading and attaching a package

    1. Package NAMESPACE is _loaded_ into the current _R_ session

    2. An environment containing exported symbols from the package is
       _attached_ to the _R_ search path

- 'Attaching' a package means that the `.GlobalEnv`'s parent points to
   the new package exported symbol environment. The new package
   exported symbol environment points to the package previously
   pointed to by `.GlobalEnv`

- A package consists of a NAMESPACE

    - A NAMESPACE is an environment.
    - The parent of the NAMESPACE is an environment containing
      imported symbols.
    - The parent of the environment with imported symbols is the base
      environment.
    - The parent of the base environment is the `.GlobalEnv`.
    - ...and so on down the search path.

- Symbol resolution in packages follows lexical scope

    - Resolved in the function, then package NAMESPACE, then imports
      environment, then base then `.GlobalEnv`, then ...

Evaluation, lazy and non-standard evaluation

### Exercises

***Exercise:*** bank account

- Congratulations, you own a bank! Here's a function that creates an
  account, and provides access to it

    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {}

       deposit <- function(amt) {}

       withdraw <- function(amt) {}

       list(available = available, deposit = deposit, withdraw = withdraw)
    }
    ```

<!--
    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {
           balance
       }

       deposit <- function(amt) {
           balance <<- balance + amt
           balance
       }

       withdraw <- function(amt) {
           if (amt > balance)
               stop("insufficient funds")
           deposit(-amt)
       }

       list(available = available, deposit = deposit, withdraw = withdraw)
    }
    ```
-->

- Implement for the following test case, using the concept of lexical scope:

    ```{r}
    library(testthat)
    test_that("I understand lexical scope", {
        acct1 <- account()
        expect_equal(acct1$deposit(10), 10)
        expect_equal(acct1$deposit(12), 22)
        expect_equal(acct1$available(), 22)
        expect_equal(acct1$withdraw(20), 2)
        expect_error(acct1$withdraw(20), "insufficient funds")
    })
    ```

- What happens when you get a second customer?

    ```{r}
    test_that("functions create local scope", {
        acct1 <- account(); acct1$deposit(10)
        acct2 <- account(); acct2$deposit(20)
        expect_equal(acct1$available(), 10)
        expect_equal(acct2$available(), 20)
    })
    ```

<!--
    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {
           balance
       }

       deposit <- function(amt) {
           balance <<- balance + amt
           funs
       }

       withdraw <- function(amt) {
           if (amt > balance)
               stop("insufficient funds")
           deposit(-amt)
       }

       funs = list(
           available = available, deposit = deposit, withdraw = withdraw
       )

       funs
    }
    ```
-->

***Exercise:*** bank account 2

- What changes to implementation would be require to allow

    ```{r}
    test_that("endomorphisms rock", {
        expect_equal(account()$deposit(10)$withdraw(5)$available(), 5)
    })
    ```

***Exercise:*** package-local options

- Implement 'package-local' options that the user can set via
  functions. Do this by using `local()` to create and populate an
  environment that contains the package-local variables as well as
  accessor functions `get()` and `set()` to retrieve / assign
  variables, e.g., `tolerance`. Here's a start, and some unit tests

    ```{r}
    .myoptions <- local({
        tolerance = 1e-4

        get = function() {
            tolerance
        }

        set = function(value) {
        }

        ## ...
    })

    ## setTolerance = ...
    ```

<!--
    ```{r}
    .myoptions <- local({
        tolerance = 1e-4
        get = function() tolerance
        list(
            get = get,
            set = function(value) {
                ovalue <- get()
                tolerance <<- value
                ovalue
            }
        )
    })

    getTolerance <- .myoptions$get
    setTolerance <- .myoptions$set
    ```
-->

- Here are some unit tests

    ```{r}
    test_that("local options can be set", {
        expect_equal(getTolerance(), 1e-4)
        ## setTolerance() returns previous value, to ease resetting
        expect_equal(otol <- setTolerance(1e-5), 1e-4)
        expect_equal(setTolerance(otol), 1e-5)
    })
    ```

## Debugging

- `browser()`
- `debug()`, `debugonce()`
- `trace()` -- especially useful for S4 methods (argument
  `signature=`), and for tracing execution (e.g.,
  `tracer = quote(print(argname))`)

# Finding the inner _R_: the C API and implementation

## Behind the curtain

From _R_ to C

S-expressions

The public API

## Old-school approaches to foreign langauges

When to worry?

- Access third-party libraries
- Novel algorithms
- Simpler reasoning
- Copy-free operations

`.C()`

`.Call()`

### Example: uuid

- uuid: globally unique id.
- Provided by [Boost uuid][uuid] 'header only' C++ library.

1. Create a package and 'src' directory

    ```{r}
    devtools::create("/tmp/uuid", list(LinkingTo = "BH"))
    dir.create("/tmp/uuid/src")
    ```

2. Write unit tests

    ```{r}
    devtools::use_testthat("/tmp/uuid")
    cat('context("uuid")
         
         test_that("uuid returns different values", {
             expect_true(is.character(uuid()))
             expect_true(length(uuid()) == 1L)
             uu <- unique(unlist(replicate(100, uuid())))
             expect_identical(length(uu), 100L)
         })', 
        file = "/tmp/uuid/tests/testthat/test_uuid.R"
    )
    ```

3. Implement the 'C++' layer

    ```{r}
    cat('#include <boost/uuid/uuid_generators.hpp>
         #include <boost/uuid/uuid_io.hpp>
         
         static boost::uuids::random_generator uuid_generator =
             boost::uuids::random_generator();

         std::string uuid_generate()
         {
             return boost::uuids::to_string(uuid_generator());
         }
        ',
        file = "/tmp/uuid/src/uuid.cpp"
    )
    ```

4. Implement the interface from C++ to _R_'s C layer.

    ```{r}
    cat('#include <Rinternals.h>

         SEXP uuid()
         {
             return mkString(uuid_generate().c_str());
         }
        ',
        file = "/tmp/uuid/src/uuid.cpp",
        append = TRUE
    )
    ```

5. Implement the interface from _C_ to _R_.

    ```{r}
    cat('#include <R_ext/Rdynload.h>
    
         extern "C" {

             static const R_CallMethodDef callMethods[] = {
                 {".uuid", (DL_FUNC) &uuid, 0},
                 {NULL, NULL, 0}
             };
             
             void R_init_uuid(DllInfo *info)
             {
                 R_registerRoutines(info, NULL, callMethods, NULL, NULL);
             }
         }
        ',
        file = "/tmp/uuid/src/uuid.cpp",
        append = TRUE
    )
    ```

6. Implement the end-user API in _R_.

    ```{r}
    cat("#' @useDynLib uuid, .registration = TRUE
         #' @export
         uuid <- function()
             .Call(.uuid)
        ",
        file = "/tmp/uuid/R/uuid.R"
    )
    ```

7. Document, test, install, use!

    ```{r}
    devtools::document("/tmp/uuid")
    devtools::test("/tmp/uuid")
    devtools::install("/tmp/uuid")
    ```

8. Return to regularly scheduled program

    ```{r}
    unlink("/tmp/uuid", recursive = TRUE)
    ```

[uuid]: http://www.boost.org/doc/libs/1_64_0/libs/uuid/

## Rcpp

## Into the weeds

Fun (?!) with `gdb`

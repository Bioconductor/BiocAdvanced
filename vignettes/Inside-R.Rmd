---
title: "Inside the mind of _R_"
author: "Martin Morgan, Herve Pages"
date: "June 19 - 20, 2017"
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
output:
  BiocStyle::html_document
---

# _R_ as we know it

## Preparation (recommended): build R from Source

- It will be helpful, but not required, to have your own _R_, built
  from source 'by hand'.
- Use SVN to check out the 'R-3-4-branch' source code

Linux (requires admin rights)

- (an easy cheat -- get dependencies by using your package manager to
  install a 'dev' version of current _R_, e.g., `sudo apt-get install r-base-dev`).
  But then do the svn stuff anyway.

- I do an SVN checkout into a 'source' directory, then build in a
  'bin' directory. I build without optimization (for easy debugging)

    ```
    mkdir -p ~/src/ && cd ~/src
    svn co https://svn.r-project.org/R/branches/R-3-4-branch
    R-3-4-branch/tools/rsync-recommended
    mkdir -p ~/bin/R-3-4-branch
    cd ~/bin/R-3-4-branch
    CFLAGS="-g -O0" CXXFLAGS="-g -O0" ~/src/R-3-4-branch/configure \
        --enable-R-shlib --enable-memory-profiling
    make -j
    ```

- Use the built version in-place (no need to install) `~/bin/R-3-4-branch/bin/R`


Mac (requires admin rights)

- Complete instructions for [building from source][mac-src-build].

[mac-src-build]: https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Installing-R-under-macOS

Windows

- Complete instructions for [building from source][windows-src-build].
- Avoid spaces in file paths.
- Install [svn command-line client][windows-svn].
- Open a PowerShell or cmd shell. Check out the R-3-4-0-branch of svn,
  as above.
- Install [Rtools][]; install everything; when asked for the _R_
  source location, point to the svn checked-out
  location. [Set the PATH environment variable][windows-setenv] to
  include the installed location of `Rtools/bin` to your PATH.
- Install MikTeX
- Build _R_ in the source directory

    ```
    cd R-3-4-branch/src/gnuwin32
    cp MkRules.dist MkRules.local
    make rsync-extsoft
    make -j
    ```

- Use your version of R, e.g., `../../bin/i386/Rgui.exe`

[windows-setenv]:  http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-gui/
[windows-svn]: https://stackoverflow.com/questions/2341134/command-line-svn-for-windows
[Rtools]: https://cran.r-project.org/bin/windows/Rtools/
[windows-src-build]: https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Building-from-source

## Symbol resolution and evaluation

Environments

- Current environment

    ```{r}
    environment()
    ```

- surprisingly central to _R_

    ```{r}
    env <- new.env()
    env[["foo"]] <- 123
    env[["foo"]]
    get("foo", env)      # equivalent (not really!)
    ls(env)
    ```

- hash table of key-value pairs
  - Key is called a `name` or `symbol` in _R_
  - constant-time lookup

- 'reference' semantics (almost all else in _R_ is 'copy-on-change' semantics)

    ```{r}
    another <- env
    env[["bar"]] <- 456
    another[["bar"]]
    ```
- All environments have a 'parent' environment

    ```{r}
    parent.env(env)
    ```

    - special environment: `emptyenv()`
    - parent environment is set during construction (argument to `new.env()`)

- Environment can be chained together as a linked list

    ```{r}
    top <- new.env(parent = emptyenv())
    mid <- new.env(parent = top)
    bot <- new.env(parent = mid)
    ```

- Symbol (key) look-up

    ```{r}
    top[["top"]] <- 1
    mid[["mid"]] <- 2
    bot[["bot"]] <- 3
    ```

- Symbols not found in the reference enviroment are looked for in the
  parent environment

    ```{r}
    get("bot", bot)
    get("mid", bot)
    tryCatch({
        get("mid", bot, inherits=FALSE) # restricts search to current env
    }, error = conditionMessage)
    bot[["mid"]]                        # NULL; `[[` restricts to current env
    ```

- Assignment is to the current environment

    ```{r}
    bot[["mid"]] <- 5
    bot[["mid"]]
    mid[["mid"]]
    ```

- Functions are intimately connected to environments

    ```{r}
    fun <- function() {
        environment()
    }
    fun()              # an environment defines the body of a function
    fun()              # new function, so new environment
    ```

- What happens to the environment in a function?

    - garbage collection (later!) when no longer referenced

- If a function body has an environment, there must be a parent environment

    ```{r}
    fun <- function() {
        env <- environment()
        list(env, parent.env(env))
    }
    fun()
    ```

    - Is the parent of the environment of a function the environment
      in which the function was _called from_, or the environment in
      which the function was _defined_?

    ```{r}
    fun <- function() {
        fun1 <- function() {
            env1 <- environment()    # envrionment created by fun1
            par1 <- parent.env(env1) # parent environment
            list(env1 = env1, par1 = par1)
        }
        env <- environment()        # environment created by fun
        par <- parent.env(env)
        list(env = env, par = par, fun1=fun1)
    }
    fun()
    ```

    - The parent of a function's environment is the environment _in
      which it was defined_ (different from the environment from which
      it was called)

    - Lookup, assignment (`<-`) and assignment to the parent(s)
      environment (`<<-`)

    ```{r}
    fun = function() {
        x0 <- 0
        x1 <- 0
        fun1 <- function() {
            y <- 1     # create local variable y
            x1 <<- 2   # assign to first occurrence of 'x' in parent env(s)
            z <<- 3    # no z in parent env(s), so created in top env
            c(x0 = x0, x1 = x1, y = y, z = z)
        }

        result <- fun1()
        list(x0 = x0, x1 = x1, result = result)
    }
    ```

- This is called **[lexical scope][]**

[lexical scope]: https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf

- When is lexical scope used?


Package namespaces, imports, and `search()`

- The `search() path

    ```{r}
    search()
    ```

- `library(BiocGenerics)`: loading and attaching a package

    1. Package NAMESPACE is _loaded_ into the current _R_ session

    2. An environment containing exported symbols from the package is
       _attached_ to the _R_ search path

- 'Attaching' a package means that the `.GlobalEnv`'s parent points to
   the new package exported symbol environment. The new package
   exported symbol environment points to the package previously
   pointed to by `.GlobalEnv`

- A package consists of a NAMESPACE

    - A NAMESPACE is an environment
    - The parent of the NAMESPACE is an environment containing imported symbols
    - The parent of the environment with imported symbols is the base environment
    - PAUSE
    - The parent of the base environment is the .GlobalEnv
    - ...and so on down the search path

- Symbol resolution in packages follows lexical scope

    - Resolved in the function, then package NAMESPACE, then imports
      environment, then base then .GlobalEnv, then ...

Evaluation, lazy and non-standard evaluation

### Exercises

***Exercise:*** bank account

- Congratulations, you own a bank! Here's a function that creates an
  account, and provides access to it

    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {}

       deposit <- function(amt) {}

       withdraw <- function(amt) {}

       list(available = available, deposit = deposit, withdraw = withdraw)
    }
    ```

<!--
    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {
           balance
       }

       deposit <- function(amt) {
           balance <<- balance + amt
           balance
       }

       withdraw <- function(amt) {
           if (amt > balance)
               stop("insufficient funds")
           deposit(-amt)
       }

       list(available = available, deposit = deposit, withdraw = withdraw)
    }
    ```
-->

- Implement for the following test case, using the concept of lexical scope:

    ```{r}
    library(testthat)
    test_that("I understand lexical scope", {
        acct1 <- account()
        expect_equal(acct1$deposit(10), 10)
        expect_equal(acct1$deposit(12), 22)
        expect_equal(acct1$available(), 22)
        expect_equal(acct1$withdraw(20), 2)
        expect_error(acct1$withdraw(20), "insufficient funds")
    })
    ```

- What happens when you get a second customer?

    ```{r}
    test_that("functions create local scope", {
        acct1 <- account(); acct1$deposit(10)
        acct2 <- account(); acct2$deposit(20)
        expect_equal(acct1$available(), 10)
        expect_equal(acct2$available(), 20)
    })
    ```

<!--
    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {
           balance
       }

       deposit <- function(amt) {
           balance <<- balance + amt
           funs
       }

       withdraw <- function(amt) {
           if (amt > balance)
               stop("insufficient funds")
           deposit(-amt)
       }

       funs = list(
           available = available, deposit = deposit, withdraw = withdraw
       )

       funs
    }
    ```
-->

***Exercise:*** bank account 2

- What changes to implementation would be require to allow

    ```{r}
    test_that("endomorphisms rock", {
        expect_equal(account()$deposit(10)$withdraw(5)$available(), 5)
    })
    ```

***Exercise:*** package-local options

- Implement 'package-local' options that the user can set via
  functions. Do this by using `local()` to create and populate an
  environment that contains the package-local variables as well as
  accessor functions `get()` and `set()` to retrieve / assign
  variables, e.g., `tolerance`. Here's a start, and some unit tests

    ```{r}
    .myoptions <- local({
        tolerance = 1e-4

        get = function() {
            tolerance
        }

        set = function(value) {
        }

        ## ...
    })

    ## setTolerance = ...
    ```

<!--
    ```{r}
    .myoptions <- local({
        tolerance = 1e-4
        get = function() tolerance
        list(
            get = get,
            set = function(value) {
                ovalue <- get()
                tolerance <<- value
                ovalue
            }
        )
    })

    getTolerance <- .myoptions$get
    setTolerance <- .myoptions$set
    ```
-->

- Here are some unit tests

    ```{r}
    test_that("local options can be set", {
        expect_equal(getTolerance(), 1e-4)
        ## setTolerance() returns previous value, to ease resetting
        expect_equal(otol <- setTolerance(1e-5), 1e-4)
        expect_equal(setTolerance(otol), 1e-5)
    })
    ```

## Memory management

Copy on change

Garbage collection

Performance consequences

## Practical techniques

Correctness

Performance

Debugging beyond `debug()`

# Finding the inner _R_: the C API and implementation

## Behind the curtain

From _R_ to C

S-expressions

The public API

## Old-school approaches to foreign langauges

When to worry?

- Access third-party libraries
- Novel algorithms
- Simpler reasoning
- Copy-free operations

`.C()`

`.Call()`

## Rcpp

## Into the weeds

Fun (?!) with `gdb`

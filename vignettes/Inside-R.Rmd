---
title: "Inside the mind of _R_"
author: "Martin Morgan, Herve Pages"
date: "June 19 - 20, 2017"
vignette: >
  %\VignetteIndexEntry{Inside the mind of R}
  %\VignetteEngine{knitr::rmarkdown}
output:
  BiocStyle::html_document
---

# _R_ as we know it

## Symbol resolution and evaluation

Environments

- Current environment

    ```{r}
    environment()
    ```

- surprisingly central to _R_

    ```{r}
    env <- new.env()
    env[["foo"]] <- 123
    env[["foo"]]
    get("foo", env)      # equivalent (not really!)
    ls(env)
    ```

- hash table of key-value pairs
  - Key is called a `name` or `symbol` in _R_
  - constant-time lookup

- 'reference' semantics (almost all else in _R_ is 'copy-on-change' semantics)

    ```{r}
    another <- env
    env[["bar"]] <- 456
    another[["bar"]]
    ```
- All environments have a 'parent' environment

    ```{r}
    parent.env(env)
    ```

    - special environment: `emptyenv()`
    - parent environment is set during construction (argument to `new.env()`)

- Environment can be chained together as a linked list

    ```{r}
    top <- new.env(parent = emptyenv())
    mid <- new.env(parent = top)
    bot <- new.env(parent = mid)
    ```

- Symbol (key) look-up

    ```{r}
    top[["top"]] <- 1
    mid[["mid"]] <- 2
    bot[["bot"]] <- 3
    ```

- Symbols not found in the reference enviroment are looked for in the
  parent environment

    ```{r}
    get("bot", bot)
    get("mid", bot)
    tryCatch({
        get("mid", bot, inherits=FALSE) # restricts search to current env
    }, error = conditionMessage)
    bot[["mid"]]                        # NULL; `[[` restricts to current env
    ```

- Assignment is to the current environment

    ```{r}
    bot[["mid"]] <- 5
    bot[["mid"]]
    mid[["mid"]]
    ```

- Functions are intimately connected to environments

    ```{r}
    fun <- function() {
        environment()
    }
    fun()              # an environment defines the body of a function
    fun()              # new function, so new environment
    ```

- What happens to the environment in a function?

    - garbage collection (later!) when no longer referenced

- If a function body has an environment, there must be a parent environment

    ```{r}
    fun <- function() {
        env <- environment()
        list(env, parent.env(env))
    }
    fun()
    ```

    - Is the parent of the environment of a function the environment
      in which the function was _called from_, or the environment in
      which the function was _defined_?

    ```{r}
    fun <- function() {
        fun1 <- function() {
            env1 <- environment()    # envrionment created by fun1
            par1 <- parent.env(env1) # parent environment
            list(env1 = env1, par1 = par1)
        }
        env <- environment()        # environment created by fun
        par <- parent.env(env)
        list(env = env, par = par, fun1=fun1)
    }
    fun()
    ```

    - The parent of a function's environment is the environment _in
      which it was defined_ (different from the environment from which
      it was called)

    - Lookup, assignment (`<-`) and assignment to the parent(s)
      environment (`<<-`)

    ```{r}
    fun = function() {
        x0 <- 0
        x1 <- 0
        fun1 <- function() {
            y <- 1     # create local variable y
            x1 <<- 2   # assign to first occurrence of 'x' in parent env(s)
            z <<- 3    # no z in parent env(s), so created in top env
            c(x0 = x0, x1 = x1, y = y, z = z)
        }

        result <- fun1()
        list(x0 = x0, x1 = x1, result = result)
    }
    ```

- This is called **[lexical scope][]**

[lexical scope]: https://www.stat.auckland.ac.nz/~ihaka/downloads/lexical.pdf

- When is lexical scope used?


Package namespaces, imports, and `search()`

- The `search() path

    ```{r}
    search()
    ```

- `library(BiocGenerics)`: loading and attaching a package

    1. Package NAMESPACE is _loaded_ into the current _R_ session

    2. An environment containing exported symbols from the package is
       _attached_ to the _R_ search path

- 'Attaching' a package means that the `.GlobalEnv`'s parent points to
   the new package exported symbol environment. The new package
   exported symbol environment points to the package previously
   pointed to by `.GlobalEnv`

- A package consists of a NAMESPACE

    - A NAMESPACE is an environment
    - The parent of the NAMESPACE is an environment containing imported symbols
    - The parent of the environment with imported symbols is the base environment
    - PAUSE
    - The parent of the base environment is the .GlobalEnv
    - ...and so on down the search path

- Symbol resolution in packages follows lexical scope

    - Resolved in the function, then package NAMESPACE, then imports
      environment, then base then .GlobalEnv, then ...

Evaluation, lazy and non-standard evaluation

### Exercises

***Exercise:*** bank account

- Congratulations, you own a bank! Here's a function that creates an
  account, and provides access to it

    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {}

       deposit <- function(amt) {}

       withdraw <- function(amt) {}

       list(available = available, deposit = deposit, withdraw = withdraw)
    }
    ```

<!--
    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {
           balance
       }

       deposit <- function(amt) {
           balance <<- balance + amt
           balance
       }

       withdraw <- function(amt) {
           if (amt > balance)
               stop("insufficient funds")
           deposit(-amt)
       }

       list(available = available, deposit = deposit, withdraw = withdraw)
    }
    ```
-->

- Implement for the following test case, using the concept of lexical scope:

    ```{r}
    library(testthat)
    test_that("I understand lexical scope", {
        acct1 <- account()
        expect_equal(acct1$deposit(10), 10)
        expect_equal(acct1$deposit(12), 22)
        expect_equal(acct1$available(), 22)
        expect_equal(acct1$withdraw(20), 2)
        expect_error(acct1$withdraw(20), "insufficient funds")
    })
    ```

- What happens when you get a second customer?

    ```{r}
    test_that("functions create local scope", {
        acct1 <- account(); acct1$deposit(10)
        acct2 <- account(); acct2$deposit(20)
        expect_equal(acct1$available(), 10)
        expect_equal(acct2$available(), 20)
    })
    ```

<!--
    ```{r}
    account <- function() {
       balance <- 0

       available <- function() {
           balance
       }

       deposit <- function(amt) {
           balance <<- balance + amt
           funs
       }

       withdraw <- function(amt) {
           if (amt > balance)
               stop("insufficient funds")
           deposit(-amt)
       }

       funs = list(
           available = available, deposit = deposit, withdraw = withdraw
       )

       funs
    }
    ```
-->

***Exercise:*** bank account 2

- What changes to implementation would be require to allow

    ```{r}
    test_that("endomorphisms rock", {
        expect_equal(account()$deposit(10)$withdraw(5)$available(), 5)
    })
    ```

***Exercise:*** package-local options

- Implement 'package-local' options that the user can set via
  functions. Do this by using `local()` to create and populate an
  environment that contains the package-local variables as well as
  accessor functions `get()` and `set()` to retrieve / assign
  variables, e.g., `tolerance`. Here's a start, and some unit tests

    ```{r}
    .myoptions <- local({
        tolerance = 1e-4

        get = function() {
            tolerance
        }

        set = function(value) {
        }

        ## ...
    })

    ## setTolerance = ...
    ```

<!--
    ```{r}
    .myoptions <- local({
        tolerance = 1e-4
        get = function() tolerance
        list(
            get = get,
            set = function(value) {
                ovalue <- get()
                tolerance <<- value
                ovalue
            }
        )
    })

    getTolerance <- .myoptions$get
    setTolerance <- .myoptions$set
    ```
-->

- Here are some unit tests

    ```{r}
    test_that("local options can be set", {
        expect_equal(getTolerance(), 1e-4)
        ## setTolerance() returns previous value, to ease resetting
        expect_equal(otol <- setTolerance(1e-5), 1e-4)
        expect_equal(setTolerance(otol), 1e-5)
    })
    ```

## Memory management

Copy on change

- It seems like _R_ variables do not share any memory

    ```{r}
    x <- y <- 1:5
    x
    y
    x[1] <- 2L
    x
    y
    ```
    
    ```{r}
    x <- 1:5
    fun = function(z) { z[1] = 2L; z }
    fun(x)
    x
    ```

    - Different from many programming languages
    - Very convenient for users -- they don't have to think about
      'change-at-a-distance'.
- _R_ uses a 'named' concept, rather than strict 'reference counting'

    - Counts the number of references to a location in memory...
    - But can only count to 2
    - So '2' means that at some point in the memory location's
      history, 2 _or more_ symbols referenced that location.
- In action

    ```{r}
    x = 1:5
    .Internal(inspect(x))
    ```
    
    - `@41de7d8`: memory address.
    - `13 INTSXP`: integer 'S-expression' (more later).
    - `[NAM(1)]`: One symbol (`x`) references the location in memory.
    
    ```{r}
    x = y = 1:5
    .Internal(inspect(x))
    .Internal(inspect(y))
    ```
    
    - `x`, `y` point to same location in memory
    - `[NAM(2)]`: (at least) two symbols reference the location
    
- 'Copy-on-change': when updating a vector, make a copy if `NAM() == 2`.

    ```{r}
    ## copy on change
    x = y = 1:5
    .Internal(inspect(x))
    x[1] = 2L
    .Internal(inspect(x))
    .Internal(inspect(y))
    
    ## no copy necessary
    x = 1:5
    .Internal(inspect(x))
    x[1] = 2L
    .Internal(inspect(x))

    ```

Garbage collection (approximate description)

- S-expressions (`SEXP`) allocated by the system to a pool of
  available S-expressions
- `x <- 1` moves the SEXP from allocated to 'in use' pool, level 0
  (the 0 in `g0c4` of `.Internal(inspect(x))`)
- After `rm(x)`, a symbol no longer references the SEXP and it is a
  candidate for re-use.
- `gc()` (manual, or more typically triggered automatically when _R_
  runs out of SEXP in the available pool)

    - Visits all SEXP in g0 pool and marks as 'unreferenced'
    - Visits all symbols in use and marks their SEXP as 'in use'
    - Visits (second time) all SEXP in g0 pool. Moves unreferenced
      symbols to the 'available' pool, moves 'in use' to the g1 pool.

- Note: SEXP belong to 'generations' and classes

    ```{r}
    y = 1
    fun = function() { x <- 1; 2 }
    fun(); gc()    # scans x, y; collects x, ages y
    fun(); gc()    # scans & collects x, does not visit y
    ```

    - g0 generation are recently allocated, and checked for
      suitability for garbage collection most frequently -- typically
      symbols allocated in functions and no longer in scope; ripe for
      collection.
    - g1 has survived increasingly many garbage collections -- package
      or globals symbols that seldom become eligible for collection.
    - Net effect: g0 nodes enriched for SEXP that can collected.

- Resources: _R_ Internals manual e.g., the
  [write barrier][R-ints-gc], Luke Tierney's [notes][gc-notes];
  [memory.c][].

[gc-notes]: http://homepage.stat.uiowa.edu/~luke/R/gengcnotes.html
[R-ints-gc]: https://cran.r-project.org/doc/manuals/r-devel/R-ints.html#The-write-barrier
[memory.c]: https://github.com/wch/r-source/blob/trunk/src/main/memory.c

Performance consequences

## Practical techniques

Correctness

Performance

Debugging beyond `debug()`

# Finding the inner _R_: the C API and implementation

## Behind the curtain

From _R_ to C

S-expressions

The public API

## Old-school approaches to foreign langauges

When to worry?

- Access third-party libraries
- Novel algorithms
- Simpler reasoning
- Copy-free operations

`.C()`

`.Call()`

### Example: mutex

- mutex: 'mutual exclusion' lock
- par

## Rcpp

## Into the weeds

Fun (?!) with `gdb`

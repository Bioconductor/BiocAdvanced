---
title: "S4 classes and methods"
author: "Martin Morgan, Hervé Pagès"
date: "June 19 - 20, 2017"
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
output: 
  BiocStyle::html_document2
---



# Preamble

S4 class system implemented in the methods package

The ingredients:

- The core components: _classes_, _generic functions_ and _methods_

- The glue: _method dispatch_

S4 classes are sometimes called _formal classes_

The result: a rich and complex system (218 symbols exported from the
methods package). Can be overwhelming. The good news is that we only need
a small subset of the system.


# Strengths of S4 (compared to S3)

**Multiple dispatch**

**Object validation**

**API vs internals** Unlike other OO programming languages, S4 offers no
provision for encapsulation: the _internals_ of an object (i.e. all its slots)
are visible and directly accessible. However, the Bioconductor approach is
to consider that the _internals_ are the business of the developer and
that the end user should never need to access them directly or even look
at them. Access should be only via _accessor functions_ (_getters_ or
_setters_).

This has the following advantages:

- The developer has the freedom to modify the internals of an object
without breaking user code.

- Carefully crafted setters will make sure that the object remains valid
when being modified by the user.

- This separation between what an object looks from the outside and what's
really inside allows the developer to use tricks at the internals
level to make objects more compact in memory and/or more efficient.

So from a user point of view what matters is the _semantic_ of an object
i.e. what it represents and how it can be manipulated (API).

Even developers who implement a new class by extending an existing class
should do it in a way that is agnostic about the internals of the class
they extend. S4 makes this possible (it's a great feature). More on this
later.

**Powerful coercion system**


**Virtual/concrete classes** A _virtual_ class is a class that cannot be
_instanciated_. Typically used as the parent of one or more concrete classes:

    setClass("A", representation("VIRTUAL"))  # virtual class
    setClass("A1", contains="A", slots=some slots)
    setClass("A2", contains="A", slots=some other slots)

For example the GRanges and GPos classes are both subclasses of virtual class
GenomicRanges:

```{r}
suppressPackageStartupMessages(library(GenomicRanges))
showClass("GenomicRanges")
```

Many methods can be implemented in a way that works for the 2 kinds of
objects.

`"names"` method:

```{r}
selectMethod("names", "GRanges")
```

Will also work on GPos objects because the `ranges()` getter works on these
objects (and like for GRanges objects, it also returns a names IRanges object).
So instead of defining 2 `"names"` methods (one for GRanges and one for GPos
objects) we define one method for GenomicRanges objects. GRanges and GPos
objects inherit it.

**Virtual classes with no slots** A virtual class can have slots (like
GenomicRanges), or no slots (like class A in our first example).
Typically the slots of a virtual class are not enough to represent
an object (this is why the class is made virtual). The concrete subclasses
add the missing slots.

**Multiple inheritance** Powerful but can lead to a class hierarchy that is
very hard to maintain if not used carefully.

```{r}
showClass("CompressedIRangesList")
```

S4 imposes no restrictions but I think we never had the need to define
a class with more than 2 direct parents.

**Class unions** Just a special kind of virtual class with no slots.

```{r}
showClass("GenomicRanges_OR_GRangesList")
```

(This class is used in the definition of RangedSummarizedExperiment objects.)

**Reference classes** Rarely needed. As a general principle, R objects
should have a pass-by-copy semantic so passing them to a function is
guaranteed to leave the original object unmodified. Pass-by-reference
semantic is almost never needed and should be avoided.


# A first example

Open _A quick overview of the S4 class system_ (PDF) on the
[S4Vectors landing page][S4Vectors_canonical_url] and go to the
_Implementing an S4 class (in 4 slides)_ section.

[S4Vectors_canonical_url]: http://bioconductor.org/packages/S4Vectors


# Essential _Bioconductor_ classes

## Motivation / necessity

Users

Developers

## Key classes for end users

- GenomicRanges
- SummariedExperiment



# Design and implementation of S4 objects


## 2 approaches

- From scratch (a rare situation)

- Extend an existing class (less work)


## What to implement

### Core stuff

- class def

- validity

- constructor

- show method

### API

**At a minimum some getters** Try to reuse existing generics instead of
introducing new ones e.g.:

- organism, score (defined in BiocGenerics), strand

- seqinfo (defined in GenomeInfoDb)

**Depending on the _shape_ of the objects, methods for some of the following core generic functions** (from base R):

    length, names, subsetting ([, [[), dim, dimnames, c(),
    setters, names<-, subassignment ([<-, [[<-), dimnames<-

**Specialized operations** As methods for existing generics (e.g. `normalize`
defined in BiocGenerics), or as new generics.

### Coercion methods

TODO (give examples)

### Subtle difference between being an "A instance" and an "A object"

TODO (give examples)


## Exercise

TODO


## About objects shape

Most objects fall in one of these categories

- vector-like: length()

  Examples: atomic vectors and ordinary list in base R
                  Rle, Hits, IRanges, GRanges, GRangesList, DNAString,
                  DNAStringSet

- list-like: vector-like + [[

  Examples: ordinary list and data frames in base R
                  CharacterList, IRanges, IRangesList, GRangesList,
                  DNAStringSet

- matrix-like, array-like objects: dim() and length(x) = prod(dim(x))

  Examples: matrix and array objects in base R, Matrix objects in the
            Matrix package, DelayedArray objects

- data-frame-like: dim() + list-like along the columns

  Examples: data.frame objects in base R, DataFrame

These categories are not mutually exclusive:

- list-like objects are vector-like objects

- array-like objects are also vector-like objects

- data-frame-like are list-like objects: length(x) = ncol(x)),
  names(x) = colnames(x), x[[i]] = x[ , i]
  They are NOT matrix-like objects.

These categories reflect the _shape_ of the object

- linear shape: vector-like, list-like

- rectangular shape: matrix-like, data-frame-like, SummarizedExperiment

- multi-dimensional shape: array-like

Rectangular and multi-dimensional objects have an "implicit linear
shape". Think of it as the "backbone" of the object.

For example, 3 linear shapes can be associated with a rectangular shape.
They are described by the following "backbones":

1) "matrix-like backbone":

    run from the top-left element to the bottom-right element of the
    rectangle, going thru the entire rectangle by running down along
    all the columns (continuing from the top of next column when reaching
    the bottom of a column)

  This is the backbone of matrix-like objects.
  Array-like objects generalize this to N dimensions: backbone runs
  along the first dimension first (fastest changing dimension in R is
  the first one), then along the 2nd dimension, and so on...)

2) "data-frame-like backbone":

    run *horizontally* from first to last column of the rectangle

  This is the backbone of data-frame-like objects.

3) Bioconductor introduces a 3rd type of backbone for rectangular objects:

    run *vertically* from first to last row of the rectangle

  This is the "SummarizedExperiment-like backbone".

When implementing a class that represents rectangular objects, the
developper should decide what the backbone of the objects will be.
Concretely that means deciding what the "length" method will return:
prod(dim(x)), ncol(x), or nrow(x)?
Once this choice is made, things like names(x), x[i], and c() should
behave consistently (e.g. c(x, y) should concatenate the 2 objects
along their backbones).

Making it clear what the backbone is in the documentation will help
the user understand (and even predict) the behavior of length(x),
names(x), x[i], c(), etc... No surprises!


**Exercise**

What's the shape of SNPLocations objects?


## Subsetting

R syntax allows 8 different forms of subsetting:

- [ vs [[

- Linear (x[i] and x[[i]], also called 1D-style subsetting) vs
  multi-dimensional (x[i_1, i_2, ..., i_n], x[[...]])
  Linear subsetting is along the length of the object
  (1 <= i <= length(x))

- Extraction ([, [[) vs replacement ([<-, [[<-) (a.k.a. "subassignment")

=> 2 x 2 x 2 = 8 forms of subsetting

Some examples:

- Ordinary matrix, array, data.frame, DataFrame objects support the 8 forms.
  Gotcha: Implicit linear shape of matrix-like and data-frame-like objects
  differ, and so do linear subsetting on them.

- SummuarizedExperiment objects support rectangular (x[i, j]) and linear
  (x[i]) subsetting. x[i] is equivalent to x[i, ].
  Plus their replacement versions.
  Gotcha: [[ is also supported but behaves in a non-standard way!

- GRanges objects support linear [ and [<- only

**Exercise**

Implement subsetting of SNPLocations objects.


## About API design

### Avoid surprising the user

TODO (give examples)

### Pay particular attention to how length, names, [, [[, c(), dim, dimnames behave

WHY (give examples)

### To be or not to be an endomorphism

#### Definition

TODO

#### Examples

- [ (drop=FALSE) (except linear subsetting on an array-like object)

- Replacement methods (including [<- and [[<-).
  Examples: names(), mcols(), seqinfo() setters on any object for which
  they are defined.
 
  But with some notable exceptions:
  - [<- on an atomic vector when the storage.mode of the vector cannot
    represent the right-value (e.g. x[2] <- 3.4 on an integer vector,
    or x[2] <- "a" on a numeric vector)

  - rowRanges() setter on a SummarizedExperiment instance.

- c() on linear objects (e.g. on Hits, GRanges, GRangesList,
        DNAStringSet objects)

- c() on rectangular objects with data-frame-like backbones
        (equivalent to cbind())

- c() on rectangular objects with SummarizedExperiment-like backbones
        (equivalent to rbind())

- Intra-range transformations (e.g. shift(), flank(), etc...)

#### NOT endomorphisms

- c() on array-like objects

- Inter-range transformations (e.g. reduce(), disjoin()) in general are
  not endomorphisms:

    gpos <- GPos(c("chr1:4-20", "chr1:50-60"))
    reduce(gpos)

### Transformation that preserve positionality

- Output "parallel" to input

  EXPLAIN

- Propagation of names and metadata columns

- Can or be an endomorphism (ismorphism) or not


## Reusing existing classes

- It's very likely that Bioconductor already has a container that handles
    the kind of data that your package needs to handle.

- If not, then maybe extending an existing class by adding a few slots
    is all you need to do.

- Starting a new class from scratch should be the last resort.
    Even in that case, it's very likely that you could extend one of the
    virtual classes that are at the bottom of our core class hierarchy.
    For example:

- by extending Annotated you get the metadata() getter and setter
      out-of-the-box.

- by extending Vector (only if your objects are vector-like objects),
      you get the above (Vector extends Annotated) + length() + the
      mcols() getter and setter out-of-the box + a mechanism to facilitate
      implemention of subsetting ([) and validation (via defining a
      "parallelSlotNames" method).

- by extending List (only if your objects are list-like objects)
      you get the above (List extends Vector) + elementType() + as.list() +
      a mechanism to facilitate implementation of [[.

- Ask on the bioc-devel mailing list if you are not sure.

### Concrete example: Extending the RangedSummarizedExperiment class.

Open _A quick overview of the S4 class system_ (PDF) on the
[S4Vectors landing page][S4Vectors_canonical_url] and go to the
_Extending an existing class_ section.


## Extending a class without adding any slot

Typically to add constraints on the object.

### Example: I want to implement a class that represent IRanges objects of constant width

One option is to extend IRanges:

  setClass("ConstantWidthIRanges", contains="IRanges")

and to add the "constant width" constraint thru a validity method:

  setValidity("ConstantWidthIRanges",
      function(object)
      {
          w <- width(object)
          if (length(w) != 0L && any(w != w[[1]]))
              return("object width is not constant")
          TRUE
      }
  )

Open a parenthesis here to discuss

      length(w) != 0L && any(w != w[[1]]

vs

      length(unique(w)) > 1

The S4 system provides automatic coercion methods from parent to child
(promotion) and from child to parent (downgrade).

There is a gotcha with these methods though.

Let's look at promotion:

  x <- as(IRanges(6:8, width=10), "ConstantWidthIRanges")
  validObject(x)
  y <- as(IRanges(6:8, end=10), "ConstantWidthIRanges")

mmmh... it worked, but it produced an invalid object:

  validObject(x)

Why?

Let's look at downgrade:

  x2 <- as(x, "IRanges")
  y2 <- as(y, "IRanges")

Works fine (both objects are valid IRanges objects)

Note that there are other approaches for implementing constant-width IRanges
objects.


## Overriding existing methods

- Override only if you see an oportunity for a more efficient implementation,
  NEVER to change the semantics.

- Examples: isEmpty() for ConstantWidthIRanges objects.

      TODO (try to find a better example)


## Extending vs composition

Let's say we want to implement a class for representing a view on an array
i.e. a multi-dimensional window on an array. The window can be represented
by a set of ranges, one range per dimension e.g. [1-4, 1-5] for the topleft
corner of a matrix. For an array with N dimensions, we need N ranges to
represent the view. We'll call this kind of object a "viewport" (by analogy
with the terminology used in the computer graphics world).

In our viewport objects, we also want to store the dimensions of "the
reference array" i.e. the array on top of which the viewport is defined
(a.k.a. "the underlying array"). This will be useful for validation purposes.

Consider the 2 following implementations:

    setClass("ArrayViewport1",
        contains="IRanges"
        representation(
            refdim="integer"
        )
    )

    setClass("ArrayViewport2",
        representation(
            refdim="integer"
            ranges="IRanges"
        )
    )

One extends the IRanges class so inerits the IRanges slots and full IRanges
API. is(x, "IRanges") will be true on these objects. This says: an
ArrayViewport1 object *is* an IRanges object so can be used anywhere an
IRanges object is expected.

The other one uses composition. An ArrayViewport2 object *is not* an IRanges
object but it *has* one (in its 'ranges' slot).

In the end, the 2 containers store the same data but their semantics are
very different. Which one to choose?

It all depends!  MORE ON THIS...

I want my viewport objects to have the shape of an array i.e. dim() should
return the dimensions of the sub-array delimitted by the viewport.

# A close look at some core Bioconductor classes

## GRangesList

TODO

## RangedSummarizedExperiment

TODO

## GPos

TODO

## ArrayGrid

TODO

# Efficiency

TODO

# Common 'tricks'

TODO

# Documenting an S4 class

TODO

# A note on long vectors

TODO

# Links

TODO

